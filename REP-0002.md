```
REP: 2
Title: PSRT Client-Side Order Expiration
Author: Radiant Core Contributors <info@radiantfoundation.org>
Status: Draft
Type: Standard
Created: 2025-12-31
License: MIT
```

## Abstract

This REP proposes client-side order expiration for the PSRT (Glyph Swap Protocol) to improve swap protocol efficiency and reduce stale order clutter. The implementation adds optional `max_age` filtering to swap RPC methods, allowing clients to automatically ignore orders older than a specified threshold.

## Specification

### RPC Interface Changes

#### getopenorders
Add optional `max_age` parameter:
```json
{
  "method": "getopenorders",
  "params": [
    {
      "asset_id": "RXD",
      "max_age": 2592000  // Optional: 30 days in seconds
    }
  ]
}
```

#### getopenordersbywant
Add optional `max_age` parameter:
```json
{
  "method": "getopenordersbywant", 
  "params": [
    {
      "want_asset_id": "BTC",
      "max_age": 2592000  // Optional: 30 days in seconds
    }
  ]
}
```

### Order Age Calculation

Order age is calculated from the `blockHeight` field in PSRT orders:

```
order_age = current_block_height - order_block_height
order_age_seconds = order_age * 300  // 5-minute block time
```

### Filtering Logic

1. **Server-side filtering**: Node filters orders before returning to client
2. **Client-side fallback**: Clients can also filter if needed
3. **Default behavior**: No filtering when `max_age` not specified
4. **Validation**: `max_age` must be between 86400 (1 day) and 7776000 (90 days)

### Implementation Details

```cpp
// In src/rpc/psrt.cpp
UniValue getopenorders(const JSONRPCRequest& request)
{
    // ... existing code ...
    
    int maxAge = 0;
    if (request.params[0].exists("max_age")) {
        maxAge = request.params[0]["max_age"].get_int();
        if (maxAge < 86400 || maxAge > 7776000) {
            throw JSONRPCError(RPC_INVALID_PARAMETER, "max_age must be between 1 and 90 days");
        }
    }
    
    // Filter orders by age
    for (const auto& order : orders) {
        if (maxAge > 0) {
            int orderAge = (chainActive.Height() - order.blockHeight) * 300;
            if (orderAge > maxAge) continue;
        }
        // ... include order in results ...
    }
}
```

## Motivation

The PSRT protocol currently accumulates orders indefinitely, leading to several issues:

1. **Stale Orders**: Orders from inactive users remain visible indefinitely
2. **UI Clutter**: Wallet interfaces show outdated orders that can't be filled
3. **Network Efficiency**: Nodes store and serve unnecessary order data
4. **User Experience**: Difficult to distinguish active from inactive orders
5. **Storage Growth**: Unbounded growth of order database

Client-side expiration provides a simple, backward-compatible solution to these problems.

## Rationale

### Why Client-Side Expiration?

1. **No Consensus Changes**: Purely client-side filtering
2. **Backward Compatible**: Existing clients continue to work
3. **Flexible**: Each client can choose appropriate expiration
4. **Simple Implementation**: Minimal code changes required
5. **Gradual Adoption**: Can be adopted incrementally

### Alternative Approaches Considered

1. **Server-side Order Expiration**: Would require consensus changes
2. **Order TTL Fields**: Requires protocol changes and storage overhead
3. **Manual Order Cleanup**: Relies on user action, unreliable
4. **Periodic Order Pruning**: Complex coordination between nodes

Client-side filtering provides the best balance of simplicity and effectiveness.

### Recommended Default Values

- **Conservative**: 90 days (7776000 seconds)
- **Moderate**: 30 days (2592000 seconds) 
- **Aggressive**: 7 days (604800 seconds)

Wallets should default to 30 days with user-configurable options.

## Backwards Compatibility

This change is fully backwards compatible:

- Existing RPC calls without `max_age` work unchanged
- No protocol or consensus changes required
- Older clients see all orders (current behavior)
- New clients can optionally filter stale orders

## Reference Implementation

### Node Changes

```cpp
// src/psrt.h
struct PSRTOrder {
    // ... existing fields ...
    int32_t blockHeight;
    
    bool isOlderThan(int maxAgeSeconds) const {
        int currentHeight = chainActive.Height();
        int ageBlocks = currentHeight - blockHeight;
        int ageSeconds = ageBlocks * 300; // 5-minute blocks
        return ageSeconds > maxAgeSeconds;
    }
};
```

### Wallet Integration

```javascript
// Photonic Wallet integration
async function fetchOpenOrders(maxAgeDays = 30) {
    const maxAgeSeconds = maxAgeDays * 24 * 60 * 60;
    
    const response = await rpc.call('getopenorders', [{
        asset_id: 'RXD',
        max_age: maxAgeSeconds
    }]);
    
    return response.result;
}
```

### Configuration Options

```ini
// radiant.conf
# Default order expiration in days (0 = no expiration)
psrt.default_order_expiration=30

# Maximum allowed expiration in days
psrt.max_order_expiration=90
```

## Security Considerations

### Potential Issues

1. **Order Front-running**: Expiration timing could be exploited
2. **Market Manipulation**: Selective order visibility
3. **Privacy Concerns**: Age filtering reveals activity patterns
4. **Network Partitioning**: Different expiration policies across network

### Mitigation Strategies

1. **Randomized Expiration**: Add small random variance to prevent timing attacks
2. **Consistent Defaults**: Encourage wallets to use similar default values
3. **Privacy Options**: Allow users to opt-out of age filtering if desired
4. **Network Monitoring**: Monitor for unusual filtering patterns

### Privacy Enhancements

```cpp
// Add randomization to prevent timing attacks
int calculateOrderAge(const PSRTOrder& order, int maxAge) {
    int baseAge = (chainActive.Height() - order.blockHeight) * 300;
    // Add Â±5% randomization
    int variance = baseAge * 0.05;
    int randomOffset = GetRand(variance * 2) - variance;
    return baseAge + randomOffset;
}
```

## Testing Strategy

### Unit Tests
- Test age calculation accuracy
- Test boundary conditions (exactly at limits)
- Test RPC parameter validation
- Test filtering logic

### Integration Tests
- Test with real order data
- Test wallet integration
- Test performance with large order sets
- Test network behavior

### Performance Tests
- Measure filtering performance impact
- Test memory usage with various expiration settings
- Benchmark RPC response times

## Deployment Plan

### Phase 1: Node Implementation
- Implement RPC parameter changes
- Add filtering logic
- Write comprehensive tests
- Deploy to testnet

### Phase 2: Wallet Integration
- Update Photonic Wallet
- Add user configuration options
- Test user experience
- Document best practices

### Phase 3: Network Monitoring
- Monitor adoption rates
- Collect performance metrics
- Gather user feedback
- Optimize based on usage patterns

## Copyright

This document is licensed under the MIT License.
