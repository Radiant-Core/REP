```
REP: 3006
Title: Encrypted Content Extension for Glyph v2
Author: C. Donnachie
Status: Draft
Type: Standard
Created: 2026-01-24
Requires: REP-3001, REP-3002
License: MIT
Original: RIP-GLYPH-0007
```

## Abstract

This proposal defines an **optional encryption extension** for **Glyph v2** that enables publishing
**encrypted payloads** (e.g., "hidden images", locked objects) while keeping the base protocol deterministic
and indexer-friendly.

Encrypted Glyphs store **ciphertext on-chain (or by reference)** and declare encryption parameters via a
standard `crypto` metadata object. Access control is not enforced by consensus; it is achieved by controlling
the **decryption key**.

## Motivation

Applications such as:

- private documents and receipts
- "unlockable" art / secret images
- game items with hidden attributes until reveal
- gated content for memberships or puzzles

benefit from a standardized way to:

- signal that content is encrypted
- specify algorithms and parameters
- hash/verify **ciphertext** deterministically
- support multiple key-delivery methods (passphrase or recipients)

---

### Non-goals

This REP does **not**:

- hide the existence of the data on-chain
- prevent copying or redistribution of ciphertext
- guarantee secrecy if the key is weak or later leaked
- define a "perfect" DRM mechanism

If ciphertext is published, it is permanent. If the key leaks later, the plaintext is revealed forever.

---

## Specification

### Compatibility & Layering

- Glyph magic remains `gly` (hex `676c79`) and v2 versioning remains unchanged.
- This extension is **purely metadata + content rules** on top of v2.
- Indexers that do not implement this REP can still:
  - index the Glyph
  - validate commit/reveal hashes
  - treat ciphertext as opaque bytes

---

### Terminology

- **CEK**: Content Encryption Key (random key used to encrypt the payload)
- **KEM / Key Wrap**: Mechanism to encrypt/wrap the CEK for recipients or a passphrase
- **Ciphertext**: Encrypted bytes stored inline or referenced
- **AAD**: Additional Authenticated Data (bytes authenticated but not encrypted)

---

### Design Overview

Two modes are defined:

#### Mode A â€” Encrypted payload, public metadata (RECOMMENDED)

- Metadata (type/name/etc.) remains readable
- `content.*.hash` refers to **ciphertext**
- Wallets display a "ðŸ”’ Encrypted" badge until key is provided

#### Mode B â€” Encrypted payload + encrypted metadata (OPTIONAL, future)

- Metadata is also encrypted (poor search/UX)
- This REP defines only Mode A. Mode B is reserved for a future REP.

---

### Algorithms (Normative)

#### Content Encryption AEAD

Implementations MUST support:

- `xchacha20poly1305` (preferred, 24-byte nonce)

Implementations MAY additionally support:

- `aes-256-gcm` (12-byte nonce)
- `chacha20poly1305` (IETF, 12-byte nonce) â€” widely available fallback

> **Note:** Python's `cryptography` library provides `chacha20poly1305` (IETF) and `aes-256-gcm`
> but not XChaCha20-Poly1305. Implementations MAY use ChaCha20-Poly1305 (IETF) as a fallback
> when XChaCha20 is unavailable. See REP-3007 for test vectors.

#### Nonce Sizes

| Algorithm           | Nonce Size |
| ------------------- | ---------- |
| `xchacha20poly1305` | 24 bytes   |
| `chacha20poly1305`  | 12 bytes   |
| `aes-256-gcm`       | 12 bytes   |

#### Passphrase-based Key Derivation (Optional)

If passphrase-derived keys are used, implementations MUST support:

- `scrypt` with parameters declared in metadata

Implementations MAY support:

- `hkdf-sha256` (for CEK expansion from other secrets)

#### Hashing

Ciphertext integrity MUST be verifiable via v2 content hashing:

- `sha256(ciphertext)` (as already used in v2 `content.*.hash`)

---

### Metadata Extension: `crypto` (Normative)

If a Glyph uses encrypted content, it MUST include a `crypto` object at top level.

#### Schema

```json
"crypto": {
  "mode": "encrypted",
  "aead": "xchacha20poly1305 | chacha20poly1305 | aes-256-gcm",
  "nonce": "hex",
  "aad": {
    "mode": "none | bytes | fields",
    "bytes": "hex-optional",
    "fields": ["content.primary.path", "content.primary.hash.hex"]
  },
  "key": {
    "format": "raw | wrapped",
    "kdf": "none | scrypt | hkdf-sha256",
    "kdf_params": { },
    "wrap": {
      "alg": "none | x25519-hkdf-aes256gcm",
      "recipients": [
        {
          "kid": "string",
          "pubkey": "hex",
          "wrapped_cek": "hex"
        }
      ]
    },
    "hint": "optional human hint (DO NOT include secret material)"
  }
}
```

#### Required Fields

When `crypto.mode="encrypted"`:

- `crypto.aead` MUST be present
- `crypto.nonce` MUST be present
- `content.*.hash` MUST refer to ciphertext bytes (see Â§9)

#### AAD Modes

- `aad.mode="none"`: no AAD
- `aad.mode="bytes"`: raw AAD provided in `aad.bytes` (hex-encoded)
- `aad.mode="fields"`: AAD is computed by concatenating canonical encodings of the listed fields

**Recommendation:** `aad.mode="fields"` to bind decryption to the declared content identity.

#### AAD Field Encoding (Normative)

When `aad.mode="fields"`, the AAD bytes are computed as follows:

1. For each field path in `aad.fields` (in order):
   - Resolve the field value from the metadata
   - Encode the value as UTF-8 bytes
   - Append a null byte (`0x00`) as separator
2. Concatenate all encoded values (without trailing null)

Example for `fields: ["content.primary.path", "content.primary.hash.hex"]`:

```
AAD = UTF8("hello.enc") || 0x00 || UTF8("fa402a9f01a52c068dfad98b5e89deb93ec4163536006e69b55a1c0d7a144e5a")
```

In hex: `68656c6c6f2e656e6300666134...`

Implementations MUST compute AAD identically to ensure decryption succeeds.

---

### Content Rules (Normative)

#### Ciphertext Hashing

For any encrypted file entry in `content.primary`, `content.files`, or `content.refs`:

- `hash.hex` MUST be `sha256(ciphertext_bytes)` (lowercase hex)
- `size` MUST be ciphertext size in bytes

#### Plaintext Metadata (Optional)

Implementations MAY include non-sensitive hints:

- `content.primary.plain_mime_hint`
- `content.primary.plain_size_hint`

These hints are non-consensus and MUST NOT be used for validation.

#### Compression Order

If compression is used, the order MUST be:

1. plaintext â†’ compress
2. compressed bytes â†’ encrypt (AEAD)
3. store ciphertext

`content.*.compression` refers to the plaintext compression method used prior to encryption.

---

### Key Delivery (Non-consensus but Standardized Fields)

This REP supports two common patterns.

#### Passphrase Unlock (Simple)

- CEK derived from passphrase via `scrypt`
- `crypto.key.kdf="scrypt"` with full parameters

**Warning:** weak passphrases are brute-forceable.

#### Recipient Unlock (Recommended for Sharing)

- Random CEK encrypts content
- CEK is wrapped per recipient public key in `crypto.key.wrap.recipients[]`

Wallets can store private keys locally and unwrap the CEK for the user.

---

### Wallet UX Requirements (Normative)

Wallets that implement REP-3006 MUST:

- visibly mark encrypted Glyphs (e.g., "ðŸ”’ Encrypted")
- never automatically publish or transmit decryption keys
- only decrypt locally
- respect `policy.executable` and MUST NOT execute decrypted content without explicit consent
- allow user to import/paste a key or select a recipient identity

Wallets SHOULD:

- support decrypting the primary file first
- cache decrypted previews locally (optional)

---

### Indexer Requirements (Normative)

Indexers that implement REP-3006 MUST:

- treat `content.*.hash` as hashes of ciphertext (no plaintext validation)
- validate commitâ†”reveal linkage as usual (REP-3001/3002)
- index `crypto.aead`, `crypto.key.format`, and presence of recipients (without exposing secrets)

Indexers MUST NOT:

- attempt to brute-force passphrases
- store plaintext unless explicitly configured by the operator

---

## Security Considerations

- On-chain ciphertext is permanent; secrecy depends on key secrecy.
- Passphrase-based CEKs require strong passphrases and a strong KDF.
- Do not reuse nonces for the same key under AEAD schemes.
- `aad.mode="fields"` reduces substitution attacks by binding ciphertext to identity fields.
- If the key is revealed later (intentionally or by accident), the content is decrypted forever.

---

## Reference Implementation

```text
canonical_meta = CanonicalSerialize(metadata)
commit_hash = SHA256(canonical_meta)

# Encrypt
plain = ReadFile(...)
plain2 = Compress(plain, compression)
cek = DeriveOrRandomCEK(...)
ciphertext = AEAD_Encrypt(aead, cek, nonce, aad, plain2)

file_hash = SHA256(ciphertext)

# Store ciphertext inline or by reference; set content.hash.hex = file_hash
```

---

### Key Rotation and Re-encryption

#### Adding Recipients

To add new recipients to an encrypted Glyph without re-encrypting content:

1. Obtain the original CEK (requires existing access)
2. Wrap CEK for the new recipient(s)
3. Publish an update adding new entries to `crypto.key.wrap.recipients[]`

This requires `mutable.allowed=true` with `crypto.key.wrap.recipients` in `mutable.fields`.

#### Revoking Recipients

Recipient revocation is NOT possible without re-encryption:

- Removing a recipient from the list does not prevent decryption
- The removed recipient still has the wrapped CEK in historical data
- True revocation requires generating a new CEK and re-encrypting content

#### Re-encryption Procedure

To fully revoke access:

1. Generate new CEK
2. Re-encrypt content with new CEK
3. Create new Glyph with updated ciphertext and new recipient list
4. Optionally mark old Glyph as superseded via `rels`

---

### Test Vectors

See **REP-3007** for deterministic test vectors including:

- AES-256-GCM vectors
- ChaCha20-Poly1305 (IETF) vectors
- Ciphertext hash examples
- Complete Glyph metadata examples

> **Note:** XChaCha20-Poly1305 vectors are planned for a future revision once a canonical
> cross-platform implementation is selected.

---

## Backwards Compatibility

This extension is purely additive and does not affect existing Glyphs. Indexers that do not implement this REP can still index encrypted Glyphs as opaque data.

## Rationale

The design prioritizes:
- Deterministic ciphertext hashing for commit/reveal integrity
- Flexibility in key delivery mechanisms
- Clear separation between consensus-level and application-level concerns

## Appendix: Minimal Example (Encrypted Image)

```json
{
  "v": 2,
  "type": "image",
  "name": "Locked Artwork #1",
  "content": {
    "mode": "inline",
    "primary": {
      "path": "art.enc",
      "mime": "application/octet-stream",
      "size": 123456,
      "hash": { "algo": "sha256", "hex": "<sha256(ciphertext)>" },
      "encoding": "raw",
      "compression": "none"
    }
  },
  "policy": { "renderable": true, "executable": false },
  "crypto": {
    "mode": "encrypted",
    "aead": "xchacha20poly1305",
    "nonce": "<24-byte nonce hex>",
    "aad": {
      "mode": "fields",
      "fields": ["content.primary.path", "content.primary.hash.hex"]
    },
    "key": {
      "format": "wrapped",
      "wrap": {
        "alg": "x25519-hkdf-aes256gcm",
        "recipients": [
          {
            "kid": "alice",
            "pubkey": "<x25519 pubkey>",
            "wrapped_cek": "<hex>"
          }
        ]
      }
    }
  }
}
```

## Copyright

This document is licensed under the MIT License.
