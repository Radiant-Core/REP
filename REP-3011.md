# REP-3011: WAVE â€” A Peer-to-Peer Radiant Blockchain Name System

| Field | Value |
|-------|-------|
| REP | 3011 |
| Title | WAVE: A Peer-to-Peer Radiant Blockchain Name System |
| Author | Radiant Community |
| Status | Draft |
| Type | Standards Track |
| Category | Token Standard |
| Created | 2026-01-25 |
| Requires | REP-3001, REP-3002 |

---

## Abstract

WAVE is a decentralized naming system built on the Radiant blockchain, providing human-readable names for payments, hostname resolution, and all functions of traditional DNS without relying on centralized name lookup services. This REP defines WAVE as a Glyph v2 profile, where name Claim Tokens are implemented as Glyph NFTs with specialized metadata and resolution logic.

---

## Motivation

Traditional DNS suffers from several weaknesses:

1. **Centralization**: Root servers and registrars are single points of failure and control
2. **Censorship**: Names can be seized or redirected by authorities
3. **Security**: DNS spoofing and cache poisoning attacks are common
4. **Cost**: Annual renewal fees with no ownership guarantee
5. **Opacity**: Users cannot verify the authenticity of DNS responses

WAVE addresses these issues by leveraging Radiant's unique reference system to create a cryptographically secure, censorship-resistant naming system where:

- Names are owned via private keys (true ownership)
- Resolution is verifiable by anyone
- No renewal fees (one-time registration)
- Immutable history prevents forgery

By implementing WAVE as a Glyph profile, we gain:

- Unified wallet and indexer infrastructure
- Standard NFT operations (transfer, display, burn)
- Mutable metadata for zone record updates
- Compatibility with Glyph v2 ecosystem

---

## Specification

### 1. Protocol Identifier

WAVE names use the following Glyph protocol identifiers:

```
p: [2, 11]  // GLYPH_NFT (2) + GLYPH_WAVE (11)
```

For mutable zone records:
```
p: [2, 5, 11]  // GLYPH_NFT + GLYPH_MUT + GLYPH_WAVE
```

### 2. Name Structure

#### 2.1 Character Set

WAVE supports 37 characters:
- Lowercase letters: `a-z` (26 characters)
- Digits: `0-9` (10 characters)
- Hyphen: `-` (1 character)

Character indices:
```
a=0, b=1, c=2, ..., z=25, 0=26, 1=27, ..., 9=35, -=36
```

#### 2.2 Prefix Tree

Names are represented as a chain of transactions forming a prefix tree:

```
Root Transaction (genesis)
â”œâ”€â”€ Output 0: Claim Token (empty name "")
â”œâ”€â”€ Output 1: 'a' branch
â”œâ”€â”€ Output 2: 'b' branch
â”œâ”€â”€ ...
â”œâ”€â”€ Output 26: 'z' branch
â”œâ”€â”€ Output 27: '0' branch
â”œâ”€â”€ ...
â”œâ”€â”€ Output 36: '9' branch
â””â”€â”€ Output 37: '-' branch

Each branch output can be spent to extend the name:

'a' branch spend:
â”œâ”€â”€ Output 0: Claim Token for "a"
â”œâ”€â”€ Output 1: 'a' branch â†’ "aa"
â”œâ”€â”€ Output 2: 'b' branch â†’ "ab"
â”œâ”€â”€ ...
â””â”€â”€ Output 37: '-' branch â†’ "a-"
```

#### 2.3 Name Length

- **Minimum**: 1 character
- **Maximum**: 63 characters (matching DNS label limits)
- **Total path depth**: Limited by transaction chain length

### 3. Transaction Contract

#### 3.1 Name Registration Transaction

A name registration transaction MUST:

1. Spend a valid branch output from the parent name
2. Create exactly 38 outputs:
   - Output 0: Claim Token (singleton ref, Glyph NFT)
   - Outputs 1-37: Branch outputs for child names
3. Include Glyph payload with WAVE metadata

#### 3.2 Claim Token Script

The Claim Token is a Glyph NFT using `OP_PUSHINPUTREFSINGLETON`:

```
OP_PUSHINPUTREFSINGLETON <claimRef>
OP_DROP
<P2PKH or custom locking script>
```

#### 3.3 Branch Output Script

Branch outputs enable extending the prefix tree:

```
OP_PUSHINPUTREF <parentRef>
OP_DROP
<character_index> OP_DROP
<P2PKH locking script>
```

Where `character_index` is 0-36 corresponding to the character this branch represents.

### 4. Glyph Metadata Schema

#### 4.1 Required Fields

```json
{
  "v": 2,
  "type": "wave_name",
  "p": [2, 11],
  "app": {
    "namespace": "rxd.wave",
    "schema": "wave_name_v1",
    "data": {
      "name": "example",
      "parent": "<parent_claim_ref or null for root>",
      "registered": <block_height>,
      "zone": {}
    }
  }
}
```

#### 4.2 Zone Record Types

Zone records are stored in `app.data.zone`:

| Record Type | Key | Value Type | Description |
|-------------|-----|------------|-------------|
| Address | `address` | string | Radiant payment address |
| Avatar | `avatar` | string | URL or content hash for avatar image |
| Name | `display` | string | Display name (can include Unicode) |
| Description | `desc` | string | Profile description |
| URL | `url` | string | Website URL |
| Email | `email` | string | Contact email |
| A Record | `A` | string | IPv4 address |
| AAAA Record | `AAAA` | string | IPv6 address |
| CNAME | `CNAME` | string | Canonical name alias |
| TXT | `TXT` | string[] | Text records |
| MX | `MX` | object[] | Mail exchange records |
| NS | `NS` | string[] | Nameserver records |
| Custom | `x-*` | any | Custom records with `x-` prefix |

#### 4.3 Example: Complete Name Registration

```json
{
  "v": 2,
  "type": "wave_name",
  "p": [2, 5, 11],
  "name": "alice",
  "desc": "Alice's WAVE name",
  "app": {
    "namespace": "rxd.wave",
    "schema": "wave_name_v1",
    "data": {
      "name": "alice",
      "parent": null,
      "registered": 850000,
      "zone": {
        "address": "1AliceRadiantAddress...",
        "avatar": "ipfs://QmAvatar...",
        "display": "Alice ðŸŒŠ",
        "url": "https://alice.example.com",
        "A": "192.168.1.100",
        "TXT": ["v=spf1 include:example.com ~all"]
      }
    }
  },
  "mutable": {
    "allowed": true,
    "controller": "<controller_ref>",
    "fields": ["/app/data/zone"]
  }
}
```

### 5. Name Resolution

#### 5.1 Resolution Algorithm

To resolve a name (e.g., "alice"):

1. Start at the WAVE root transaction (well-known genesis)
2. For each character in the name:
   a. Find the branch output corresponding to the character
   b. Follow the spend chain to the latest transaction
3. The Claim Token (output 0) of the final transaction is the resolved name
4. Fetch the Glyph metadata attached to the Claim Token
5. Return zone records from metadata

#### 5.2 Subdomain Resolution

For subdomains (e.g., "mail.alice"):

1. Resolve "alice" to get the Claim Token
2. Check if "alice" has delegated "mail" subdomain
3. If delegated: resolve "mail" from alice's branch outputs
4. If not delegated: name does not exist

#### 5.3 Resolution Proof

Resolvers MUST provide proof of resolution:

```json
{
  "name": "alice",
  "claim_ref": "<claim_token_ref>",
  "proof": {
    "path": [
      {"char": "a", "txid": "...", "vout": 1},
      {"char": "l", "txid": "...", "vout": 12},
      {"char": "i", "txid": "...", "vout": 9},
      {"char": "c", "txid": "...", "vout": 3},
      {"char": "e", "txid": "...", "vout": 5}
    ],
    "claim_tx": "...",
    "current_owner": "<owner_address>"
  },
  "zone": { ... }
}
```

### 6. Zone Record Updates

Since WAVE names use `GLYPH_MUT`, zone records can be updated:

#### 6.1 Update Transaction

```json
{
  "v": 2,
  "schema": "glyph_update_v1",
  "target": "<claim_token_ref>",
  "update": {
    "op": "merge",
    "path": "/app/data/zone",
    "value": {
      "address": "<new_address>",
      "A": "10.0.0.1"
    }
  },
  "auth": {
    "controller": "<controller_ref>",
    "sig": "<signature>"
  }
}
```

#### 6.2 Update Rules

- Only the controller can update zone records
- Updates are recorded on-chain with full history
- Resolvers MUST follow the update chain to get latest records

### 7. Permissions and Delegation

#### 7.1 Subdomain Delegation

Name owners can delegate subdomains to other addresses:

```json
{
  "app": {
    "data": {
      "delegations": {
        "mail": {
          "address": "1MailAdminAddress...",
          "permissions": ["register", "update"]
        },
        "dev": {
          "address": "1DevTeamAddress...",
          "permissions": ["register", "update", "delegate"]
        }
      }
    }
  }
}
```

#### 7.2 Permission Types

| Permission | Description |
|------------|-------------|
| `register` | Can register subdomains |
| `update` | Can update zone records |
| `delegate` | Can delegate to others |
| `transfer` | Can transfer ownership |
| `revoke` | Can revoke delegations |

### 8. Internationalization

#### 8.1 Punycode Encoding

WAVE uses Punycode (RFC 3492) for internationalized domain names:

- Unicode names are converted to ASCII-compatible encoding
- Encoded names start with `xn--` prefix
- Example: `æ—¥æœ¬` â†’ `xn--wgv71a`

#### 8.2 Display Rules

- Wallets SHOULD display the Unicode form to users
- Protocol operations use the Punycode form
- Metadata MAY include `display` field with Unicode

### 9. Root Genesis

#### 9.1 Root Transaction

The WAVE root is a well-known genesis transaction that:

- Contains 38 outputs for all first-level names
- Is immutable (no mutable controller)
- Has a known transaction ID published in this REP

#### 9.2 Root Transaction ID

```
WAVE_ROOT_TXID: <to be determined at activation>
```

### 10. Indexer Requirements

WAVE-compatible indexers MUST:

1. Index all transactions with `GLYPH_WAVE` protocol ID
2. Build and maintain the prefix tree structure
3. Track Claim Token ownership and transfers
4. Index zone record updates
5. Provide resolution API endpoints

#### 10.1 Suggested API Endpoints

```
GET /wave/resolve/:name
GET /wave/lookup/:claim_ref
GET /wave/subdomains/:name
GET /wave/history/:name
POST /wave/register
POST /wave/update
```

### 11. Security Considerations

#### 11.1 Front-Running Prevention

Name registration is vulnerable to front-running. Mitigations:

1. **Commit-Reveal**: Users commit to a name hash, then reveal
2. **Time-locked registration**: Brief waiting period after commit
3. **MEV protection**: Use private mempools when available

#### 11.2 Squatting Prevention

To discourage name squatting:

1. **Registration cost**: Branch outputs require photon funding
2. **Use-it-or-lose-it**: Future REP may add expiration mechanism
3. **Dispute resolution**: Community governance for trademark issues

#### 11.3 Resolution Security

- Resolvers MUST verify the full proof chain
- Clients SHOULD verify proofs independently
- Zone records are only as secure as the owner's private key

### 12. Backwards Compatibility

This REP introduces a new Glyph protocol ID (`GLYPH_WAVE = 11`). Existing Glyph indexers will recognize WAVE names as NFTs but may not understand the specialized resolution logic.

WAVE-unaware wallets will:
- Display Claim Tokens as standard NFTs âœ“
- Allow transfers âœ“
- Not understand zone records âœ—
- Not resolve names âœ—

### 13. Reference Implementation

#### 13.1 Name Registration (TypeScript)

```typescript
import { GLYPH_NFT, GLYPH_MUT, GLYPH_WAVE } from './protocols';

const WAVE_CHARS = 'abcdefghijklmnopqrstuvwxyz0123456789-';

function charToIndex(char: string): number {
  const idx = WAVE_CHARS.indexOf(char.toLowerCase());
  if (idx === -1) throw new Error(`Invalid WAVE character: ${char}`);
  return idx;
}

function createWaveNamePayload(
  name: string,
  parentRef: string | null,
  zone: Record<string, unknown>
): object {
  return {
    v: 2,
    type: 'wave_name',
    p: [GLYPH_NFT, GLYPH_MUT, GLYPH_WAVE],
    name,
    app: {
      namespace: 'rxd.wave',
      schema: 'wave_name_v1',
      data: {
        name,
        parent: parentRef,
        registered: null, // Set by indexer
        zone
      }
    },
    mutable: {
      allowed: true,
      fields: ['/app/data/zone']
    }
  };
}

function createRegistrationOutputs(
  claimAddress: string,
  branchAddress: string
): Output[] {
  const outputs: Output[] = [];
  
  // Output 0: Claim Token
  outputs.push({
    script: nftScript(claimAddress, '<claimRef>'),
    value: 1
  });
  
  // Outputs 1-37: Branch outputs
  for (let i = 0; i < 37; i++) {
    outputs.push({
      script: branchScript(branchAddress, i),
      value: 1
    });
  }
  
  return outputs;
}
```

#### 13.2 Name Resolution (TypeScript)

```typescript
async function resolveWaveName(
  name: string,
  indexer: WaveIndexer
): Promise<WaveResolution> {
  const chars = name.toLowerCase().split('');
  let currentRef = WAVE_ROOT_REF;
  const path: PathStep[] = [];
  
  for (const char of chars) {
    const charIndex = charToIndex(char);
    const branch = await indexer.getBranch(currentRef, charIndex);
    
    if (!branch) {
      throw new Error(`Name not found: ${name}`);
    }
    
    path.push({
      char,
      txid: branch.txid,
      vout: branch.vout
    });
    
    currentRef = branch.claimRef;
  }
  
  const claim = await indexer.getClaimToken(currentRef);
  const metadata = await indexer.getGlyphMetadata(currentRef);
  
  return {
    name,
    claim_ref: currentRef,
    proof: { path, claim_tx: claim.txid },
    zone: metadata.app.data.zone,
    owner: claim.owner
  };
}
```

---

## Test Vectors

### Vector 1: Simple Name Registration

**Name**: `alice`

**Character path**:
```
a = index 0, output 1
l = index 11, output 12
i = index 8, output 9
c = index 2, output 3
e = index 4, output 5
```

**Metadata (canonical CBOR)**:
```json
{
  "v": 2,
  "type": "wave_name",
  "p": [2, 5, 11],
  "name": "alice",
  "app": {
    "namespace": "rxd.wave",
    "schema": "wave_name_v1",
    "data": {
      "name": "alice",
      "parent": null,
      "zone": {
        "address": "1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa"
      }
    }
  }
}
```

### Vector 2: Subdomain

**Name**: `mail.alice`

**Resolution**:
1. Resolve `alice` â†’ get alice's Claim Token
2. Check alice's delegations for `mail`
3. Resolve `mail` from alice's branch outputs

### Vector 3: Internationalized Name

**Unicode**: `æ—¥æœ¬`
**Punycode**: `xn--wgv71a`

**Stored name**: `xn--wgv71a`
**Display name**: `æ—¥æœ¬`

---

## Rationale

### Why Glyph Profile Instead of Separate Standard?

1. **Unified infrastructure**: Wallets and indexers already support Glyphs
2. **NFT semantics**: Claim Tokens are naturally NFTs
3. **Mutable metadata**: Zone records fit Glyph's mutable model
4. **Ecosystem coherence**: One standard for all Radiant assets

### Why 37 Characters?

- 26 letters + 10 digits + hyphen = 37
- Matches DNS label character set
- Punycode handles internationalization
- 38 outputs (claim + 37 branches) is manageable

### Why Prefix Tree?

- Enables incremental registration (don't need all names at once)
- Natural hierarchy for subdomains
- Efficient lookup via tree traversal
- Proven structure from DNS and other naming systems

---

## Future Extensions

1. **Expiration mechanism**: Time-based name renewal
2. **Auction system**: Fair price discovery for premium names
3. **ENS compatibility**: Bridge to Ethereum Name Service
4. **DNSSEC integration**: Hybrid resolution with traditional DNS
5. **Wildcard records**: `*.alice` matching

---

## References

1. Satoshi Nakamoto, "Bitcoin: A Peer-to-Peer Electronic Cash System," 2008
2. "Radiant: A Peer-to-Peer Digital Asset System," 2022
3. "Glyph Protocol v2," REP-3001
4. "Punycode: RFC 3492," IETF
5. "DNSSEC: DNS Security Extensions," IETF

---

## Copyright

This REP is licensed under the MIT License.
