# REP-3012: Glyph On-Chain Royalties

| Field | Value |
|-------|-------|
| REP | 3012 |
| Title | Glyph On-Chain Royalties |
| Author | Radiant Community |
| Status | Draft |
| Type | Standards Track |
| Category | Token Standard |
| Created | 2026-01-25 |
| Requires | REP-3001, REP-3002 |

---

## Abstract

This REP defines a standard mechanism for on-chain royalty enforcement in Glyph v2 tokens. Creators can specify royalty terms at mint time that are enforced at the script level, ensuring royalty payments cannot be bypassed for compliant transfers. The specification supports percentage-based royalties, minimum amounts, and multi-party splits.

---

## Motivation

Digital creators deserve compensation when their work is resold. Current approaches to NFT royalties rely on:

1. **Marketplace enforcement**: Platforms voluntarily honor royalties, but users can trade peer-to-peer to bypass
2. **Social pressure**: Community shaming of royalty bypass, which has limited effectiveness
3. **Off-chain tracking**: Indexers track sales and calculate owed royalties, but payment is voluntary

Radiant's programmable UTXO model enables true on-chain enforcement where:
- Royalty terms are embedded in the token contract
- Non-compliant transfers fail script validation
- Bypass is cryptographically impossible for enforced tokens

This REP defines both **enforced** (on-chain) and **advisory** (off-chain) royalty modes to give creators flexibility.

---

## Specification

### 1. Protocol Integration

On-chain royalties are an extension to `GLYPH_NFT` (protocol ID 2). No new protocol ID is required; royalties are configured via the `royalty` metadata field and enforced via the token script.

### 2. Royalty Metadata Schema

#### 2.1 Root Object

```json
{
  "royalty": {
    "enforced": true,
    "bps": 500,
    "address": "<primary_recipient_address>",
    "minimum": 1000,
    "maximum": null,
    "splits": [
      { "address": "<address1>", "bps": 400, "role": "creator" },
      { "address": "<address2>", "bps": 100, "role": "platform" }
    ]
  }
}
```

#### 2.2 Field Specifications

| Field | Type | Required | Default | Description |
|-------|------|----------|---------|-------------|
| `enforced` | boolean | Yes | - | On-chain enforcement enabled |
| `bps` | integer | Yes | - | Total royalty in basis points (1 bps = 0.01%) |
| `address` | string | Yes | - | Primary royalty recipient address |
| `minimum` | integer | No | 0 | Minimum royalty amount in photons |
| `maximum` | integer | No | null | Maximum royalty amount in photons |
| `splits` | array | No | [] | Royalty distribution splits |

#### 2.3 Split Object

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `address` | string | Yes | Recipient address |
| `bps` | integer | Yes | Share in basis points (of total royalty) |
| `role` | string | No | Optional role label (creator, platform, etc.) |

**Validation rules**:
- `bps` MUST be between 0 and 10000 (0% to 100%)
- Sum of `splits[].bps` MUST equal `royalty.bps`
- If `splits` is empty, entire royalty goes to `address`

### 3. Royalty Calculation

#### 3.1 Basic Calculation

```
royalty_amount = sale_price * bps / 10000
```

#### 3.2 With Minimum/Maximum

```
raw_royalty = sale_price * bps / 10000
clamped_royalty = MAX(raw_royalty, minimum)
if maximum is not null:
    clamped_royalty = MIN(clamped_royalty, maximum)
final_royalty = clamped_royalty
```

#### 3.3 Split Distribution

```
for each split in splits:
    split_amount = final_royalty * split.bps / total_bps
    pay split_amount to split.address
```

### 4. On-Chain Enforcement

#### 4.1 Enforced NFT Script

When `enforced: true`, the NFT locking script includes royalty validation:

```
// Standard NFT singleton
OP_PUSHINPUTREFSINGLETON <tokenRef>
OP_DROP

// Royalty enforcement begins
OP_STATESEPARATOR

// Get sale price (assumed to be in a specific output or calculated)
// Method 1: Designated price output
<price_output_index> OP_OUTPUTVALUE
OP_DUP

// Calculate royalty: price * bps / 10000
<bps> OP_MUL
<10000> OP_DIV

// Apply minimum
OP_DUP
<minimum> OP_LESSTHAN
OP_IF
    OP_DROP
    <minimum>
OP_ENDIF

// Store calculated royalty
OP_TOALTSTACK

// Verify royalty output exists with correct value
<royalty_output_index> OP_OUTPUTVALUE
OP_FROMALTSTACK
OP_GREATERTHANOREQUAL OP_VERIFY

// Verify royalty recipient
<royalty_output_index> OP_OUTPUTBYTECODE
<royalty_p2pkh_script> OP_EQUAL OP_VERIFY

// Standard P2PKH for transfer authorization
<P2PKH>
```

#### 4.2 Multi-Split Enforcement

For multiple royalty recipients:

```
// For each split recipient
<split1_output_index> OP_OUTPUTVALUE
<expected_split1_amount> OP_GREATERTHANOREQUAL OP_VERIFY
<split1_output_index> OP_OUTPUTBYTECODE
<split1_p2pkh_script> OP_EQUAL OP_VERIFY

<split2_output_index> OP_OUTPUTVALUE
<expected_split2_amount> OP_GREATERTHANOREQUAL OP_VERIFY
<split2_output_index> OP_OUTPUTBYTECODE
<split2_p2pkh_script> OP_EQUAL OP_VERIFY

// ... continue for all splits
```

#### 4.3 Price Discovery

The sale price for royalty calculation can be determined by:

**Method A: Designated Price Output**
- Transaction includes a payment output to the seller (previous owner)
- Script validates against this payment output value

**Method B: Total Output Value**
- Royalty calculated on total non-royalty output value
- Simpler but may include unrelated outputs

**Method C: Signed Price Attestation**
- External oracle signs the sale price
- More complex but accurate for complex transactions

**Recommended**: Method A for simplicity and clarity.

#### 4.4 Standardized Price Discovery for RXD Sales (Swaps)

For RXD-priced sales (including swapindex orderbook offers), the sale price MUST be the photon value of the seller payment output.

**Canonical output ordering (enforced royalties)**:

1. **Output 0**: NFT output to buyer (new owner script)
2. **Output 1**: Seller payment output (RXD), as specified by swap offer `price_terms`
3. **Output 2..N**: Royalty output(s), in order:
   - If `splits` is empty: one output paying `royalty.address`
   - If `splits` is present: one output per split, in the order listed
4. **Remaining outputs**: change, fees, other outputs (MUST appear after royalty outputs)

Under this template:
- `price_output_index` MUST be `1`
- `royalty_output_index` MUST be `2` (single-recipient case)
- For split royalties, split outputs MUST start at index `2` and continue sequentially.

#### 4.5 Price Discovery for Non-RXD Sales

For non-RXD sales, the sale price MUST be explicitly declared in the transaction.

### 5. Advisory (Non-Enforced) Royalties

#### 5.1 Metadata Only

When `enforced: false`, royalty terms are advisory:

```json
{
  "royalty": {
    "enforced": false,
    "bps": 500,
    "address": "1CreatorAddress..."
  }
}
```

#### 5.2 Indexer Responsibilities

For non-enforced royalties, indexers SHOULD:
1. Track all transfers of the token
2. Identify sales (transfers with payment)
3. Calculate owed royalties per sale
4. Maintain a royalty ledger per token
5. Provide API for querying unpaid royalties

#### 5.3 Marketplace Integration

Marketplaces SHOULD:
1. Read royalty terms from metadata
2. Include royalty payment in sale transactions
3. Display royalty information to buyers
4. Track royalty payment status

### 6. Wallet Implementation

#### 6.1 Display Requirements

Wallets MUST:
- Display royalty terms when viewing token details
- Show whether royalty is enforced or advisory
- Warn users if royalty payment is required

#### 6.2 Transfer Flow (Enforced)

```
1. User initiates transfer/sale
2. Wallet reads royalty terms from metadata
3. If sale price detected:
   a. Calculate royalty amount
   b. Add royalty output(s) to transaction
   c. Validate script will accept transaction
4. Sign and broadcast
```

#### 6.2.1 RXD-Priced Sales and Swaps (Standardized Template)

For RXD-priced sales (including swapindex orderbook offers), wallets MUST construct the completion transaction using the standardized output ordering described in Section 4.4.

Wallets MUST ensure:
- Output indices match `price_output_index = 1` and `royalty_output_index = 2` (single-recipient)
- Any change outputs are placed after royalty outputs
- The seller payment output (index 1) value is used as the sale price for royalty calculation

#### 6.3 Transfer Flow (Advisory)

```
1. User initiates transfer/sale
2. Wallet reads royalty terms from metadata
3. Prompt user: "Include royalty payment of X photons?"
4. If yes, add royalty output
5. Sign and broadcast
```

### 7. Exemptions

#### 7.1 Non-Sale Transfers

Royalties apply to **sales** (transfers with payment), not:
- Gifts (zero-value transfers)
- Wallet migrations
- Smart contract interactions

#### 7.2 Detecting Sales

A transfer is considered a sale if:
- Payment output value is used as the sale price (for standardized RXD sales)
- Marketplace contract is involved (optional)

#### 7.3 Zero-Royalty Transfers

For enforced royalties, non-sale transfers:
- Include the standardized seller payment output with value 0
- Royalty calculates to 0 (or minimum)
- If minimum > 0, user must pay minimum for any transfer

### 8. Examples

#### 8.1 Simple 5% Royalty

```json
{
  "v": 2,
  "type": "nft",
  "p": [2],
  "name": "Artwork #1",
  "royalty": {
    "enforced": true,
    "bps": 500,
    "address": "1ArtistAddress..."
  }
}
```

**Sale of 10,000 photons**:
- Royalty: 10,000 × 500 / 10,000 = 500 photons to artist

#### 8.2 Royalty with Minimum

```json
{
  "royalty": {
    "enforced": true,
    "bps": 250,
    "address": "1ArtistAddress...",
    "minimum": 1000
  }
}
```

**Sale of 10,000 photons**:
- Raw royalty: 10,000 × 250 / 10,000 = 250 photons
- Minimum applies: 1,000 photons to artist

#### 8.3 Multi-Party Split

```json
{
  "royalty": {
    "enforced": true,
    "bps": 1000,
    "address": "1ArtistAddress...",
    "splits": [
      { "address": "1ArtistAddress...", "bps": 700, "role": "creator" },
      { "address": "1PlatformAddress...", "bps": 200, "role": "platform" },
      { "address": "1CharityAddress...", "bps": 100, "role": "charity" }
    ]
  }
}
```

**Sale of 100,000 photons**:
- Total royalty: 100,000 × 1,000 / 10,000 = 10,000 photons
- Artist (70%): 7,000 photons
- Platform (20%): 2,000 photons
- Charity (10%): 1,000 photons

#### 8.4 Capped Royalty

```json
{
  "royalty": {
    "enforced": true,
    "bps": 500,
    "address": "1ArtistAddress...",
    "minimum": 100,
    "maximum": 100000
  }
}
```

**Sale of 10,000,000 photons**:
- Raw royalty: 10,000,000 × 500 / 10,000 = 500,000 photons
- Maximum applies: 100,000 photons to artist

### 9. Security Considerations

#### 9.1 Price Manipulation

Risk: Buyer and seller collude to report low price.

Mitigation:
- Use price declaration output that is cryptographically bound
- Marketplace escrow contracts enforce honest pricing
- Community monitoring of suspicious transactions

#### 9.2 Minimum Royalty Griefing

Risk: High minimum prevents low-value transfers.

Mitigation:
- Creators should set reasonable minimums
- Wallets should warn about high minimums before purchase
- Consider `maximum` to cap royalty burden

#### 9.3 Script Size Limits

Multi-split enforcement increases script size. Limits:
- Maximum 10 splits recommended
- Each split adds ~50 bytes to script
- Total royalty script should stay under 1 KB

#### 9.4 Address Changes

Risk: Creator loses access to royalty address.

Mitigation:
- Use multisig or threshold addresses
- Combine with `GLYPH_MUT` for updateable royalty address
- Future REP could define royalty address migration

### 10. Backwards Compatibility

- Tokens without `royalty` field have no royalty obligations
- v1 tokens are royalty-free by default
- Non-enforced royalties work with any v1 wallet
- Enforced royalties require v2-compatible wallets

### 11. Reference Implementation

#### 11.1 Royalty Script Generator (TypeScript)

```typescript
import { Script, Opcode } from '@radiantblockchain/radiantjs';

interface RoyaltyConfig {
  enforced: boolean;
  bps: number;
  address: string;
  minimum?: number;
  maximum?: number;
  splits?: Array<{ address: string; bps: number }>;
}

function createRoyaltyScript(
  tokenRef: string,
  ownerAddress: string,
  royalty: RoyaltyConfig
): string {
  const script = new Script();
  
  // Singleton ref
  script.add(Script.fromASM(`OP_PUSHINPUTREFSINGLETON ${tokenRef} OP_DROP`));
  
  if (royalty.enforced) {
    script.add(Opcode.OP_STATESEPARATOR);
    
    // Price from designated output (index 1)
    script.add(Script.fromASM('OP_1 OP_OUTPUTVALUE'));
    
    // Calculate royalty: price * bps / 10000
    script.add(Script.fromASM(`${royalty.bps} OP_MUL 10000 OP_DIV`));
    
    // Apply minimum if specified
    if (royalty.minimum && royalty.minimum > 0) {
      script.add(Script.fromASM(
        `OP_DUP ${royalty.minimum} OP_LESSTHAN OP_IF OP_DROP ${royalty.minimum} OP_ENDIF`
      ));
    }
    
    // Apply maximum if specified
    if (royalty.maximum) {
      script.add(Script.fromASM(
        `OP_DUP ${royalty.maximum} OP_GREATERTHAN OP_IF OP_DROP ${royalty.maximum} OP_ENDIF`
      ));
    }
    
    // Verify royalty output (index 2) has correct value
    script.add(Script.fromASM('OP_2 OP_OUTPUTVALUE OP_SWAP OP_GREATERTHANOREQUAL OP_VERIFY'));
    
    // Verify royalty recipient
    const royaltyP2pkh = Script.buildPublicKeyHashOut(royalty.address).toHex();
    script.add(Script.fromASM(`OP_2 OP_OUTPUTBYTECODE ${royaltyP2pkh} OP_EQUAL OP_VERIFY`));
  }
  
  // Standard P2PKH
  script.add(Script.buildPublicKeyHashOut(ownerAddress));
  
  return script.toHex();
}
```

#### 11.2 Royalty Calculation (TypeScript)

```typescript
function calculateRoyalty(
  salePrice: number,
  royalty: RoyaltyConfig
): { total: number; splits: Array<{ address: string; amount: number }> } {
  let total = Math.floor(salePrice * royalty.bps / 10000);
  
  if (royalty.minimum && total < royalty.minimum) {
    total = royalty.minimum;
  }
  
  if (royalty.maximum && total > royalty.maximum) {
    total = royalty.maximum;
  }
  
  const splits = royalty.splits?.map(split => ({
    address: split.address,
    amount: Math.floor(total * split.bps / royalty.bps)
  })) || [{ address: royalty.address, amount: total }];
  
  return { total, splits };
}
```

#### 11.3 Wallet Integration Notes (Photonic)

Photonic Wallet implements REP-3012 compatibility for RXD-priced NFT sales by:
- Using the seller payment output value as the sale price
- Enforcing canonical output ordering for completion transactions: NFT-to-buyer, seller payment, royalty outputs, then change

Build verification:

```
pnpm -s check-types
pnpm -s -F @photonic/app check-types
```

Both commands complete successfully.

---

## Test Vectors

### Vector 1: Basic Royalty Calculation

**Input**:
```json
{
  "salePrice": 1000000,
  "royalty": {
    "bps": 500,
    "minimum": 0,
    "maximum": null
  }
}
```

**Output**:
```json
{
  "royaltyAmount": 50000
}
```

### Vector 2: Minimum Applied

**Input**:
```json
{
  "salePrice": 1000,
  "royalty": {
    "bps": 500,
    "minimum": 1000
  }
}
```

**Output**:
```json
{
  "rawRoyalty": 50,
  "royaltyAmount": 1000
}
```

### Vector 3: Multi-Split

**Input**:
```json
{
  "salePrice": 100000,
  "royalty": {
    "bps": 1000,
    "splits": [
      { "address": "addr1", "bps": 700 },
      { "address": "addr2", "bps": 300 }
    ]
  }
}
```

**Output**:
```json
{
  "totalRoyalty": 10000,
  "splits": [
    { "address": "addr1", "amount": 7000 },
    { "address": "addr2", "amount": 3000 }
  ]
}
```

---

## Rationale

### Why Basis Points?

- Industry standard for financial calculations
- Avoids floating-point precision issues
- 1 bps = 0.01%, allowing fine-grained control
- Maximum 10000 bps = 100%

### Why Optional Enforcement?

- Some creators prefer marketplace flexibility
- Lower script complexity for advisory royalties
- Backwards compatibility with existing ecosystems
- Market can determine value of enforced vs advisory

### Why Minimum/Maximum?

- **Minimum**: Ensures meaningful payment for low-value sales
- **Maximum**: Caps royalty for high-value sales, encouraging trading

---

## References

1. "Glyph Protocol v2 Core," REP-3001
2. "Glyph v2 Envelope Formats," REP-3002
3. EIP-2981: NFT Royalty Standard (Ethereum)
4. Radiant Script Reference

---

## Copyright

This REP is licensed under the MIT License.
