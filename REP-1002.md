```
REP: 1002
Title: Radiant Security Best Practices
Author: Radiant Core Contributors <info@radiantfoundation.org>
Status: Draft
Type: Informational
Created: 2025-12-31
License: MIT
```

## Abstract

This document outlines security best practices for Radiant Core node operators, developers, and users. It covers operational security, development security, and user protection strategies to ensure the safety and integrity of the Radiant ecosystem.

## Overview

Security is a critical aspect of blockchain systems. This document provides comprehensive guidelines for securing Radiant nodes, developing secure applications, and protecting user assets. These practices are based on industry standards and Radiant-specific considerations.

## Node Operation Security

### 1. Basic Node Security

#### System Security
```bash
# Use dedicated user account
sudo useradd -m -s /bin/bash radiant
sudo usermod -L radiant  # Lock password login

# Secure file permissions
chmod 700 ~/.radiant/
chmod 600 ~/.radiant/radiant.conf
```

#### Network Security
```ini
# radiant.conf security settings
rpcbind=127.0.0.1          # Bind RPC to localhost only
rpcallowip=10.0.0.0/8      # Restrict to trusted networks
rpcuser=your_rpc_user       # Set RPC username
rpcpassword=strong_password # Use strong RPC password
```

#### Firewall Configuration
```bash
# UFW firewall rules
sudo ufw allow 8333/tcp     # P2P port
sudo ufw allow from 10.0.0.0/8 to any port 8332  # RPC from trusted network
sudo ufw deny 8332/tcp      # Block external RPC access
sudo ufw enable
```

### 2. Advanced Node Security

#### SSL/TLS for RPC
```ini
# Enable SSL for RPC
rpcssl=1
rpcsslcertificatechainfile=/path/to/cert.pem
rpcsslprivatekeyfile=/path/to/key.pem
```

#### Tor Integration
```ini
# Tor hidden service for RPC
proxy=127.0.0.1:9050
torcontrol=127.0.0.1:9051
torpassword=your_tor_password
```

#### Process Isolation
```bash
# Use systemd with isolation
[Unit]
Description=Radiant Core Daemon
After=network.target

[Service]
User=radiant
Group=radiant
Type=forking
PIDFile=/var/run/radiant/radiant.pid
ExecStart=/usr/local/bin/radiantd -daemon
PrivateTmp=true
ProtectSystem=full
NoNewPrivileges=true
```

### 3. Key Management

#### Wallet Encryption
```bash
# Encrypt wallet on creation
radiant-cli encryptwallet "strong_passphrase"

# Set passphrase timeout (in seconds)
radiant-cli walletpassphrase "strong_passphrase" 60
```

#### Backup Strategies
```bash
# Backup wallet
cp ~/.radiant/wallet.dat ~/.radiant/backup/wallet_$(date +%Y%m%d).dat

# Backup important configuration
cp ~/.radiant/radiant.conf ~/.radiant/backup/radiant_$(date +%Y%m%d).conf
```

#### Multi-signature Setup
```bash
# Create 2-of-3 multisig address
radiant-cli addmultisigaddress 2 '["pubkey1","pubkey2","pubkey3"]'
```

## Development Security

### 1. Secure Coding Practices

#### Input Validation
```cpp
// Always validate input parameters
bool ValidateAmount(const CAmount& amount) {
    if (amount < 0) return false;
    if (amount > MAX_MONEY) return false;
    return true;
}

// Validate script data
bool ValidateScriptData(const std::vector<unsigned char>& data) {
    if (data.empty()) return false;
    if (data.size() > MAX_SCRIPT_ELEMENT_SIZE) return false;
    return true;
}
```

#### Memory Management
```cpp
// Secure memory handling for sensitive data
class SecureString {
private:
    std::vector<char> data;
    
public:
    ~SecureString() {
        // Zero out memory
        std::fill(data.begin(), data.end(), 0);
    }
    
    void assign(const std::string& str) {
        data.resize(str.size());
        std::copy(str.begin(), str.end(), data.begin());
    }
};
```

#### Cryptographic Security
```cpp
// Use proper cryptographic functions
uint256 CalculateHash(const std::vector<unsigned char>& data) {
    return Hash(data.begin(), data.end());
}

// Secure random number generation
std::array<uint8_t, 32> GenerateSecureRandom() {
    std::array<uint8_t, 32> random;
    GetStrongRandBytes(random.data(), random.size());
    return random;
}
```

### 2. RPC Security

#### Authentication
```cpp
// Implement proper RPC authentication
bool AuthenticateRPC(const std::string& username, const std::string& password) {
    // Use proper password hashing
    std::string hash = HashPassword(password);
    return VerifyHash(username, hash);
}
```

#### Rate Limiting
```cpp
class RateLimiter {
private:
    std::unordered_map<std::string, std::deque<std::chrono::steady_clock::time_point>> requests;
    
public:
    bool allowRequest(const std::string& clientIP) {
        auto now = std::chrono::steady_clock::now();
        auto& clientRequests = requests[clientIP];
        
        // Remove old requests (older than 1 minute)
        while (!clientRequests.empty() && 
               clientRequests.front() < now - std::chrono::minutes(1)) {
            clientRequests.pop_front();
        }
        
        // Check rate limit (e.g., 100 requests per minute)
        if (clientRequests.size() >= 100) {
            return false;
        }
        
        clientRequests.push_back(now);
        return true;
    }
};
```

### 3. Network Security

#### Peer Validation
```cpp
class PeerValidator {
public:
    bool validatePeer(const CNode& node) {
        // Check peer version
        if (node.nVersion < MIN_PROTOCOL_VERSION) return false;
        
        // Check connection limits
        if (node.GetRefCount() > MAX_CONNECTIONS_PER_IP) return false;
        
        // Check for suspicious behavior
        if (hasSuspiciousActivity(node.addr)) return false;
        
        return true;
    }
};
```

#### DDoS Protection
```cpp
class DDoSProtection {
private:
    std::unordered_map<CNetAddr, std::deque<std::chrono::steady_clock::time_point>> connectionAttempts;
    
public:
    bool allowConnection(const CNetAddr& addr) {
        auto now = std::chrono::steady_clock::now();
        auto& attempts = connectionAttempts[addr];
        
        // Remove old attempts
        while (!attempts.empty() && 
               attempts.front() < now - std::chrono::hours(1)) {
            attempts.pop_front();
        }
        
        // Check connection rate
        if (attempts.size() >= MAX_CONNECTIONS_PER_HOUR) {
            return false;
        }
        
        attempts.push_back(now);
        return true;
    }
};
```

## User Security

### 1. Wallet Security

#### Strong Passwords
```bash
# Use strong, unique passwords
# Minimum 16 characters, mixed case, numbers, symbols
radiant-cli encryptwallet "Tr0ub4dour&3W!th$tr0ngP@ssw0rd"
```

#### Hardware Wallets
- Use hardware wallets for large amounts
- Keep hardware wallet firmware updated
- Verify addresses on device screen
- Use reputable hardware wallet brands

#### Paper Wallets
```bash
# Generate secure paper wallet
radiant-cli getnewaddress > paper_wallet_address.txt
# Print and store securely offline
```

### 2. Transaction Security

#### Verification Practices
```bash
# Always verify transaction details before sending
radiant-cli gettransaction "txid"
radiant-cli decoderawtransaction "hex"

# Use replace-by-fee for urgent transactions
radiant-cli bumpfee "txid"
```

#### Fee Management
```bash
# Set appropriate fees
radiant-cli settxfee 0.00001  # 1000 satoshis per byte

# Use fee estimation
radiant-cli estimatesmartfee 6
```

#### Address Reuse Prevention
```bash
# Use new addresses for each transaction
radiant-cli getnewaddress
radiant-cli getrawchangeaddress
```

### 3. Backup and Recovery

#### Multiple Backup Locations
```bash
# Local backup
cp -r ~/.radiant/ /backup/radiant_local/

# Remote encrypted backup
tar -czf - ~/.radiant/ | gpg --cipher-algo AES256 -c > /backup/radiant_remote.tar.gz.gpg
```

#### Recovery Testing
```bash
# Test recovery on separate machine
# 1. Install Radiant Core
# 2. Restore wallet from backup
# 3. Verify access to funds
# 4. Test small transaction
```

## Network Security

### 1. P2P Security

#### Connection Security
```ini
# Limit connections
maxconnections=50
maxuploadtarget=500    # MB per day

# Peer filtering
dnsseed=1
addnode=trusted.node1:8333
addnode=trusted.node2:8333
```

#### Future P2P Encryption (REP-0004)
```ini
# When implemented
v2transport=1
preferencrypted=1
```

### 2. RPC Security

#### Access Control
```ini
# Restrict RPC access
rpcbind=127.0.0.1
rpcallowip=192.168.1.0/24
rpcport=8332
```

#### SSL Configuration
```bash
# Generate SSL certificate
openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes
```

## Operational Security

### 1. Monitoring and Alerting

#### Log Monitoring
```bash
# Monitor for suspicious activity
tail -f ~/.radiant/debug.log | grep -E "(ERROR|WARNING|suspicious)"
```

#### Health Checks
```bash
# Node health script
#!/bin/bash
if ! radiant-cli getblockchaininfo > /dev/null 2>&1; then
    echo "Node is not responding" | mail -s "Radiant Node Alert" admin@example.com
fi
```

### 2. Update Management

#### Secure Updates
```bash
# Verify GPG signatures
gpg --verify radiant-core-1.0.0.tar.gz.asc radiant-core-1.0.0.tar.gz

# Checksum verification
sha256sum radiant-core-1.0.0.tar.gz
```

#### Update Process
```bash
# Backup before update
cp -r ~/.radiant/ ~/.radiant.backup/

# Stop node
radiant-cli stop

# Update binaries
sudo cp new-radiantd /usr/local/bin/
sudo cp new-radiant-cli /usr/local/bin/

# Restart
radiantd -daemon
```

## Incident Response

### 1. Security Incident Types

#### Common Incidents
- Unauthorized RPC access
- Wallet compromise
- Node synchronization issues
- Network attacks (DDoS, eclipse)

### 2. Response Procedures

#### Immediate Actions
```bash
# Stop node if compromised
radiant-cli stop

# Isolate affected system
sudo iptables -A INPUT -s <attacker_ip> -j DROP

# Preserve evidence
cp ~/.radiant/debug.log /tmp/incident_$(date +%Y%m%d_%H%M%S).log
```

#### Investigation Steps
1. Review logs for suspicious activity
2. Check wallet balances and transactions
3. Verify node synchronization status
4. Scan for malware or unauthorized access
5. Document timeline and actions taken

### 3. Recovery Procedures

#### Wallet Recovery
```bash
# Restore from backup
cp ~/.radiant.backup/wallet.dat ~/.radiant/wallet.dat

# Verify wallet integrity
radiant-cli getwalletinfo
```

#### Node Recovery
```bash
# Reindex blockchain if needed
radiantd -reindex

# Resync from trusted peers
radiantd -addnode=trusted.node:8333
```

## Compliance and Legal

### 1. Regulatory Considerations

#### AML/KYC Requirements
- Understand local regulations
- Implement appropriate controls
- Maintain transaction records
- Report suspicious activities

#### Privacy Considerations
- Understand privacy implications
- Implement appropriate privacy controls
- Educate users about privacy risks
- Balance privacy with compliance

### 2. Audit Requirements

#### Security Audits
- Regular security assessments
- Code reviews for custom implementations
- Penetration testing of public-facing services
- Third-party security audits

#### Compliance Audits
- Regulatory compliance checks
- Data protection compliance
- Financial regulations adherence
- Industry standard compliance

## Tools and Resources

### 1. Security Tools

#### Monitoring Tools
- `radiant-cli getnetworkinfo` - Network status
- `radiant-cli getmempoolinfo` - Mempool status
- Log analysis tools (grep, awk, sed)
- Network monitoring (nmap, wireshark)

#### Security Utilities
- GnuPG for encryption
- OpenSSL for certificates
- Fail2ban for intrusion detection
- UFW for firewall management

### 2. Educational Resources

#### Documentation
- [Radiant Developer Notes](../doc/developer-notes.md)
- [Security Best Practices Guide](https://bitcoin.org/en/secure-your-wallet)
- [Cryptographic Standards](https://www.ietf.org/)

#### Community Resources
- Security forums and discussion groups
- Bug bounty programs
- Security conferences and workshops
- Online security courses

## Checklist

### Node Setup Security
- [ ] Use dedicated user account
- [ ] Configure firewall properly
- [ ] Set strong RPC passwords
- [ ] Enable SSL/TLS for RPC
- [ ] Implement rate limiting
- [ ] Set up monitoring
- [ ] Create backup procedures
- [ ] Document security procedures

### Development Security
- [ ] Follow secure coding practices
- [ ] Implement input validation
- [ ] Use proper memory management
- [ ] Implement rate limiting
- [ ] Conduct security testing
- [ ] Use code review process
- [ ] Keep dependencies updated
- [ ] Document security measures

### User Security
- [ ] Use strong wallet passwords
- [ ] Enable wallet encryption
- [ ] Create regular backups
- [ ] Use hardware wallets for large amounts
- [ ] Verify transaction details
- [ ] Practice address hygiene
- [ ] Keep software updated
- [ ] Monitor account activity

## Conclusion

Security is an ongoing process that requires constant vigilance and improvement. This document provides a foundation for secure Radiant node operation, development, and usage, but security practices must evolve as new threats emerge.

Regular security reviews, community collaboration, and staying informed about security developments are essential for maintaining a secure Radiant ecosystem. All participants in the Radiant network have a role to play in maintaining security.

## References

- [Bitcoin Security Guide](https://bitcoin.org/en/secure-your-wallet)
- [OWASP Security Guidelines](https://owasp.org/)
- [Cryptographic Best Practices](https://www.ietf.org/)
- [Radiant Developer Documentation](../doc/developer-notes.md)
- [Related REPs](README.md)

## Copyright

This document is licensed under the MIT License.
