```
REP: 3010
Title: Glyph Mining Enhancement: Multi-Algorithm POW & Dynamic Difficulty
Author: Radiant Core Contributors <info@radiantfoundation.org>
Status: Draft
Type: Standard
Created: 2026-01-25
Requires: REP-3001
License: MIT
```

## Abstract

This proposal defines enhancements to the Glyph dMint (decentralized minting) contract system to support multiple Proof-of-Work algorithms and dynamic difficulty adjustment mechanisms. The goal is to make Glyph mining fairer, more accessible to home miners, and more interesting for token creators by providing algorithm and difficulty adjustment choices at contract creation time.

Currently, all dMint contracts use SHA256d with a fixed difficulty target. This proposal introduces:
- **4 POW algorithms**: SHA256d (existing), Blake3, KangarooTwelve (K12), Argon2id-Light
- **5 Difficulty Adjustment Algorithms (DAA)**: Fixed, Epoch-Based, ASERT, LWMA, Creator Schedule
- **Collision mitigation**: Recommendations and UI guidance to reduce wasted mining work

## Motivation

### Current Limitations

The existing dMint system has several constraints:

1. **Single Algorithm (SHA256d)**: All contracts use SHA256d, which is highly optimized for ASICs and mining farms, disadvantaging home GPU miners.

2. **Fixed Difficulty**: The target is set at contract creation and never changes, leading to:
   - Unpredictable mining times as network hashrate fluctuates
   - Potential for contracts to become too easy or too hard over time
   - No mechanism for creators to implement interesting economic curves

3. **Limited Creator Control**: Token creators cannot differentiate their mining experience or target specific hardware demographics.

4. **Solution Collision Problem**: On low-difficulty contracts with multiple miners, valid solutions are often found simultaneously. Only one transaction can spend the contract UTXO, resulting in wasted work for other miners—analogous to orphaned blocks.

### Goals

1. **Fairness**: Enable algorithms that favor home GPU miners over large farms
2. **Flexibility**: Give creators control over mining economics
3. **Stability**: Provide predictable block times through dynamic difficulty
4. **Diversity**: Support multiple hardware types (GPU, CPU)
5. **Efficiency**: Reduce wasted work from solution collisions
6. **Backward Compatibility**: Existing SHA256d contracts continue to work unchanged

---

## Specification

### Contract Encoding

#### Legacy Format (Unchanged)

Existing contracts use this format and remain fully supported:

```
<height:4> d8 <contractRef:36> d0 <tokenRef:36>
<maxHeight:var> <reward:var> <target:var>
<contract_bytecode>
```

Legacy contracts are identified by the absence of the algorithm byte after the target push.

#### Enhanced Format

New contracts with algorithm and DAA selection use:

```
<height:4> d8 <contractRef:36> d0 <tokenRef:36>
<maxHeight:var> <reward:var> <target:var>
<algoId:1> <daaMode:1> <daaParams:var>
<contract_bytecode>
```

### Algorithm Identifiers

| ID | Algorithm | Type | Target Hardware |
|----|-----------|------|-----------------|
| `0x00` | SHA256d | GPU-optimized | All GPUs, ASICs |
| `0x01` | Blake3 | GPU-friendly | Modern GPUs |
| `0x02` | KangarooTwelve | GPU-friendly | Modern GPUs |
| `0x03` | Argon2id-Light | Memory-hard | GPUs with 64MB+ VRAM |
| `0x04` | RandomX-Light | CPU-only | Reserved for future |

#### SHA256d (0x00)

The existing algorithm, maintained for backward compatibility.

```
hash = sha256(sha256(
    sha256(currentLocationTxid + contractRef) +
    sha256(anyInputHash + anyOutputHash) +
    nonce
))
```

#### Blake3 (0x01)

High-performance, GPU-friendly algorithm with excellent parallelization.

```
hash = blake3(
    blake3(currentLocationTxid + contractRef) +
    blake3(anyInputHash + anyOutputHash) +
    nonce
)
```

**Rationale**: Blake3 offers ~5x speedup over SHA256 on GPUs while maintaining cryptographic security. It's not ASIC-optimized, favoring general-purpose hardware.

#### KangarooTwelve (0x02)

Keccak-based algorithm optimized for modern CPUs and GPUs.

```
hash = k12(
    k12(currentLocationTxid + contractRef) +
    k12(anyInputHash + anyOutputHash) +
    nonce,
    customization_string = "GlyphMine"
)
```

**Rationale**: K12 provides excellent performance on both CPU and GPU while being distinct from SHA256, preventing hash reuse attacks.

#### Argon2id-Light (0x03)

Memory-hard algorithm that levels the playing field between hardware tiers.

```
hash = argon2id(
    password = currentLocationTxid + contractRef + anyInputHash + anyOutputHash,
    salt = nonce,
    memory = 64MB,    // Configurable: 64-256MB
    iterations = 1,
    parallelism = 1
)
```

**Rationale**: Memory-hardness prevents GPU farms from achieving linear scaling. A 64MB requirement is accessible to most GPUs while creating a more level playing field.

### DAA Mode Identifiers

| ID | Mode | Description |
|----|------|-------------|
| `0x00` | Fixed | Static target (current behavior) |
| `0x01` | Epoch | Bitcoin-style periodic adjustment |
| `0x02` | ASERT | Exponential moving average |
| `0x03` | LWMA | Linearly weighted moving average |
| `0x04` | Schedule | Creator-defined difficulty curve |

#### Fixed (0x00)

No adjustment. Target remains constant throughout contract lifetime.

**Parameters**: None (uses initial target only)

#### Epoch-Based (0x01)

Adjusts difficulty every N mints based on actual vs expected time.

**Parameters**:
```
epochLength:       varint  // Mints per epoch (e.g., 100)
targetBlockTime:   varint  // Seconds per mint (e.g., 60)
maxAdjustment:     varint  // Max adjustment factor (e.g., 4x = 400%)
```

**Algorithm**:
```
if (currentHeight % epochLength == 0) {
    actualTime = time since epoch start
    expectedTime = epochLength * targetBlockTime
    adjustment = actualTime / expectedTime
    adjustment = clamp(adjustment, 1/maxAdjustment, maxAdjustment)
    newTarget = oldTarget * adjustment
}
```

#### ASERT (0x02)

Aserti3-2d algorithm (exponential moving average), as used by Bitcoin Cash.

**Parameters**:
```
targetBlockTime:   varint  // Seconds per mint
halfLife:          varint  // Seconds for 2x adjustment
anchorHeight:      varint  // Reference height
anchorTarget:      bigint  // Reference target
anchorTimestamp:   varint  // Reference timestamp
```

**Algorithm**:
```
timeDelta = currentTimestamp - anchorTimestamp
heightDelta = currentHeight - anchorHeight
expectedTime = heightDelta * targetBlockTime
exponent = (timeDelta - expectedTime) / halfLife
newTarget = anchorTarget * 2^exponent
```

#### LWMA (0x03)

Linearly Weighted Moving Average for responsive difficulty adjustment.

**Parameters**:
```
windowSize:        varint  // Number of blocks to average (e.g., 60)
targetBlockTime:   varint  // Seconds per mint
```

**Algorithm**:
```
weightedSum = 0
weightTotal = 0
for i in range(windowSize):
    weight = i + 1
    solveTime = block[height-i].time - block[height-i-1].time
    weightedSum += solveTime * weight
    weightTotal += weight
    
averageSolveTime = weightedSum / weightTotal
adjustment = targetBlockTime / averageSolveTime
newTarget = oldTarget * adjustment
```

#### Creator Schedule (0x04)

Predetermined difficulty curve defined at contract creation.

**Parameters**:
```
scheduleType:      uint8   // 0=linear, 1=exponential, 2=stepped
scheduleParams:    varies  // Type-specific parameters
```

**Schedule Types**:

- **Linear (0x00)**: `target = startTarget + (endTarget - startTarget) * (height / maxHeight)`
- **Exponential (0x01)**: `target = startTarget * (endTarget/startTarget)^(height/maxHeight)`
- **Stepped (0x02)**: Array of `[height, target]` breakpoints

### State Storage

For dynamic DAA modes (Epoch, ASERT, LWMA), state is stored on-chain in the contract output:

```
<current_target:8> <last_adjustment_height:4> <last_adjustment_time:4> <state_data:var>
```

**Rationale**: On-chain storage was chosen over computed-from-history for:
- Faster reads without indexing requirements
- Simpler miner implementation
- Self-contained contract verification

### Contract Verification

The dMint contract bytecode MUST be updated to:
1. Read the algorithm ID and verify the hash using the correct algorithm
2. Read the DAA mode and calculate the current target
3. Verify the submitted work meets the current target

---

## Collision Mitigation

### Problem Statement

When multiple miners work on the same low-difficulty contract, valid solutions are often found within seconds of each other. Since only one transaction can spend the contract UTXO, all other miners' work is wasted. This is especially problematic for:

- Popular contracts with many concurrent miners
- Low-difficulty contracts where solutions come quickly
- Miners with slower network connections (higher latency to mempool)

### How Dynamic DAA Helps

Dynamic difficulty adjustment naturally mitigates collisions:

1. **ASERT/LWMA**: If solutions come faster than the target block time, difficulty increases automatically, spacing out solutions and reducing collision probability.

2. **Target Block Time**: Creators specify desired time between solutions (e.g., 60 seconds). The DAA maintains this spacing regardless of miner count.

3. **Self-Regulating**: More miners → faster solutions → higher difficulty → fewer collisions.

### Recommended Minimum Difficulty

To prevent excessive collisions, implementations SHOULD enforce or recommend minimum difficulties:

| Algorithm | Recommended Minimum | Approx. Time (RTX 4090) |
|-----------|--------------------|-----------------------|
| SHA256d | 500,000 | ~30 seconds |
| Blake3 | 2,500,000 | ~30 seconds |
| K12 | 2,000,000 | ~30 seconds |
| Argon2id-Light | 50,000 | ~30 seconds |

**Rationale**: A 30-second minimum solution time significantly reduces collision probability while still providing engaging mining experience.

### Wallet UI Requirements (Normative)

Wallets creating dMint contracts MUST:

1. **Display Collision Warning**: When difficulty is below recommended minimum, show:
   > "⚠️ Low difficulty may result in ~X% of solutions being orphaned due to collisions with other miners."

2. **Show Estimated Collision Rate**: Calculate and display based on:
   ```
   collisionRate = 1 - (1 / expectedMinersPerWindow)
   ```
   Where `expectedMinersPerWindow` is estimated from similar contracts.

3. **Recommend Dynamic DAA**: When Fixed difficulty is selected with low target, suggest:
   > "Consider using ASERT or LWMA difficulty adjustment to automatically prevent collisions as more miners join."

4. **Default to Dynamic DAA**: New contracts SHOULD default to ASERT with a 60-second target block time.

### Miner UI Requirements (Normative)

Miners SHOULD:

1. **Display Current Collision Rate**: Track and show percentage of submitted solutions that were orphaned.

2. **Warn on High-Collision Contracts**: If observed collision rate exceeds 20%, display:
   > "⚠️ High collision rate on this contract. Consider mining a different contract or waiting for difficulty to adjust."

3. **Show Competing Miners**: If detectable, display estimated number of concurrent miners.

### Future Considerations

For contracts where collision remains problematic, future REPs may define:

1. **Solution Commitment Scheme**: Two-phase mining where miners commit to solutions before revealing, eliminating races.

2. **Nonce Partitioning**: Coordinated nonce range assignment to prevent overlapping work.

3. **Pool Coordination Protocol**: Standard for mining pools to coordinate on dMint contracts.

These are out of scope for this REP but may be addressed in future proposals.

---

## Miner Implementation

### Algorithm Detection

Miners MUST:
1. Parse the contract script to extract algorithm ID
2. Default to SHA256d (0x00) if no algorithm byte is present (legacy contracts)
3. Fail gracefully with "Unsupported algorithm" if the algorithm is unknown

### WebGPU Shaders

Each algorithm requires a WebGPU compute shader:
- `sha256d.wgsl` - Existing implementation
- `blake3.wgsl` - New implementation
- `k12.wgsl` - New implementation
- `argon2light.wgsl` - New implementation (requires buffer allocation)

### Target Calculation

For dynamic DAA modes, miners MUST:
1. Fetch the current contract state from the output
2. Calculate the current target using the appropriate DAA algorithm
3. Mine against the calculated target

---

## Wallet Implementation

### Contract Creation UI

Token creators MUST be presented with:
1. **Algorithm Selection**: Dropdown with algorithm descriptions and expected hashrates
2. **DAA Mode Selection**: Dropdown with mode descriptions (default: ASERT)
3. **DAA Parameters**: Conditional inputs based on selected mode
4. **Difficulty Preview**: Estimated time-to-mine based on reference hardware
5. **Collision Warning**: Dynamic warning when difficulty is too low (see §Collision Mitigation)

### Parameter Validation

Wallets MUST validate:
- Algorithm ID is supported
- DAA parameters are within reasonable bounds
- Total script size does not exceed network limits
- Difficulty meets recommended minimum (warn if not, allow override)

---

## Backwards Compatibility

### Existing Contracts

All existing dMint contracts continue to work unchanged:
- No algorithm byte = SHA256d assumed
- No DAA byte = Fixed difficulty assumed
- Existing miners can mine existing contracts without updates

### Updated Miners

Updated miners MUST:
- Support all existing SHA256d/Fixed contracts
- Support new algorithm/DAA combinations
- Fail gracefully on unknown algorithms with clear error messages

### Legacy Miners

Legacy miners encountering enhanced contracts will:
- Fail to parse the contract correctly
- Display "Unsupported contract format" or similar error
- Users will be prompted to update their miner software

---

## Security Considerations

### Algorithm Security

All proposed algorithms have extensive cryptographic analysis:
- **Blake3**: BLAKE family, proven secure, used in production systems
- **KangarooTwelve**: Keccak-based (SHA-3 family), NIST approved foundation
- **Argon2id**: Winner of Password Hashing Competition, designed for memory-hardness

### DAA Manipulation

Dynamic DAA modes could potentially be manipulated:
- **Mitigation**: ASERT and LWMA use weighted averages resistant to short-term manipulation
- **Mitigation**: Epoch-based adjustment includes clamping to prevent extreme swings
- **Mitigation**: All adjustments are deterministic and verifiable on-chain

### Memory Exhaustion (Argon2)

Argon2id-Light requires significant GPU memory:
- **Mitigation**: Miners detect GPU memory limits before attempting
- **Mitigation**: Clear error messages if memory allocation fails
- **Mitigation**: Memory parameter is fixed at contract creation (no runtime changes)

### Hash Competition

New algorithms are intentionally distinct from Radiant's consensus algorithm (SHA256d):
- Prevents miners from dual-mining with the same hardware cycles
- Isolates Glyph mining economics from network security concerns

### Collision-Based Attacks

Low difficulty could be exploited to grief miners:
- **Mitigation**: Wallet warnings discourage excessively low difficulty
- **Mitigation**: Dynamic DAA automatically increases difficulty when solutions come too fast
- **Mitigation**: Miners can detect high-collision contracts and choose alternatives

---

## Rationale

### Why Multiple Algorithms?

Different algorithms serve different communities:
- **SHA256d**: Backward compatibility, familiar to existing miners
- **Blake3**: High performance for competitive GPU mining
- **K12**: Balance between CPU and GPU accessibility
- **Argon2id-Light**: Levels playing field, memory-bound rather than compute-bound

### Why Dynamic DAA?

Fixed difficulty has proven problematic in production:
- Contracts become "too easy" as more miners join
- Contracts become "stuck" if miners leave
- Collision rates spike on popular contracts

Dynamic DAA solves all three issues with minimal complexity.

### Why On-Chain State?

Storing DAA state on-chain (vs computing from history) provides:
- O(1) state lookup vs O(n) history traversal
- Self-contained verification without external indexes
- Simpler miner implementation

The cost is slightly larger script sizes, which is acceptable given the benefits.

---

## Reference Implementation

### Glyph Miner

Reference implementation in the Glyph Miner repository:
- `src/shaders/` - WebGPU shader implementations
- `src/algorithms/` - Algorithm module system
- `src/daa/` - DAA calculation modules

### Photonic Wallet

Reference implementation in the Photonic Wallet repository:
- `packages/lib/src/script.ts` - Contract encoding functions
- `packages/app/src/pages/Mint.tsx` - Creator UI

### Implementation Phases

1. **Phase 1**: Blake3 + Infrastructure (Weeks 1-3)
2. **Phase 2**: All 5 DAA modes (Weeks 4-5)
3. **Phase 3**: K12 + Argon2id-Light (Weeks 6-8)
4. **Phase 4**: Polish + Documentation (Weeks 9-10)

---

## Test Vectors

### Blake3

```
Input:  0x0000000000000000000000000000000000000000000000000000000000000000
Output: 0xaf1349b9f5f9a1a6a0404dea36dcc9499bcb25c9adc112b7cc9a93cae41f3262
```

### KangarooTwelve

```
Input:  "" (empty)
Custom: "GlyphMine"
Output: 0x1ac2d450fc3b4205d19da7bfca1b37513c0803577ac7167f06fe2ce1f0ef39e5
```

### Contract Encoding

```
// Enhanced contract with Blake3 + ASERT
Algorithm: 0x01 (Blake3)
DAA Mode:  0x02 (ASERT)
Params:    targetBlockTime=60, halfLife=86400, anchor...

// Legacy contract (unchanged)
Algorithm: (not present, defaults to 0x00)
DAA Mode:  (not present, defaults to 0x00)
```

---

## Future Extensions

### CLI Miner

A standalone Electron/Node.js miner for:
- Multi-GPU support
- CPU-only algorithms (RandomX-Light)
- Headless operation

### Additional Algorithms

- **RandomX-Light (0x04)**: CPU-optimized, reserved for CLI miner
- **Ethash-Light**: Potential future addition for GPU diversity

### Cross-Contract DAA

Future consideration: DAA that considers multiple contracts' activity for network-wide difficulty coordination.

### Solution Commitment Scheme

Two-phase mining to eliminate collision races entirely (see §Collision Mitigation).

---

## References

- [Blake3 Specification](https://github.com/BLAKE3-team/BLAKE3-specs/blob/master/blake3.pdf)
- [KangarooTwelve Specification](https://keccak.team/kangarootwelve.html)
- [Argon2 RFC 9106](https://www.rfc-editor.org/rfc/rfc9106.html)
- [ASERT DAA (Bitcoin Cash)](https://read.cash/@jtoomim/bch-upgrade-proposal-use-asert-as-the-new-daa-1d875696)
- [LWMA Algorithm](https://github.com/zawy12/difficulty-algorithms/issues/3)
- [Glyph Miner PRD](https://github.com/AustinLee1020/Glyph-miner/blob/master/docs/GLYPH_MINING_PRD.md)

---

## Copyright

This document is licensed under the MIT License.
