```
REP: 3002
Title: Glyph v2 Envelopes (Exact Script Templates)
Author: C. Donnachie
Status: Draft
Type: Standard
Created: 2026-01-24
Requires: REP-3001
License: MIT
Original: RIP-GLYPH-0003
```

## Abstract

This REP standardizes the **exact script layout** for Glyph v2 commit/reveal/update envelopes.

Two envelope styles are specified:

- **Style A (OP_RETURN payload)**: compact, output-only, indexer-friendly
- **Style B (OP_3 "chunked" payload)**: compatible with existing parsers that scan for `OP_3` + magic bytes + CBOR

Implementations MAY support either or both styles. If both are supported, Style B is RECOMMENDED for compatibility with existing Glyph tooling.

## Motivation

A standardized envelope format is essential for interoperability between wallets, indexers, and applications. Without exact script templates, implementations may produce incompatible transactions.

## Specification

### Constants

- `MAGIC` = ASCII `gly` (3 bytes): hex `676c79`
- `V2` = `0x02`
- `SHA256` digest length = 32 bytes

### Envelope Type Discriminator

To distinguish commit from reveal in Style A:

- Commit: `MAGIC || V2 || flags` where `flags & 0x80 == 0`
- Reveal: `MAGIC || V2 || 0x80` (high bit set indicates reveal)

In Style B, the discriminator is implicit based on the structure of subsequent pushes.

### Flags Byte (Bitfield)

`flags` is 1 byte:

- bit0 (0x01): `has_content_root`
- bit1 (0x02): `has_controller`
- bit2 (0x04): `has_profile_hint`
- bit7 (0x80): `is_reveal` (Style A only)
- remaining bits reserved (MUST be 0)

### Size Limits (Normative)

| Envelope Type | Style A Max | Style B Max         |
| ------------- | ----------- | ------------------- |
| Commit        | 100 KB      | 100 KB              |
| Reveal        | 100 KB      | 520 KB (multi-push) |
| Update        | 64 KB       | 64 KB               |

Indexers SHOULD reject envelopes exceeding these limits.

### Varint Encoding

Variable-length integers in TLV structures use **Bitcoin-style CompactSize**:

- 0x00–0xFC: 1 byte (value as-is)
- 0xFD: 3 bytes (0xFD + uint16 LE)
- 0xFE: 5 bytes (0xFE + uint32 LE)
- 0xFF: 9 bytes (0xFF + uint64 LE)

---

### Commit Envelope

#### Commit Payload Binary Layout (Normative)

In v2, **magic is carried as its own push** (Style B) or as the first bytes in the OP_RETURN payload (Style A).
The v2 _payload_ begins with the version byte.

```
commit_payload :=
  V2[1] || flags[1] || commit_hash[32]
  || (content_root[32] if flags&0x01)
  || (controller_tlv if flags&0x02)
  || (profile_hint_tlv if flags&0x04)
```

##### controller_tlv (when present)

TLV format:

- `t` (1 byte)
- `len` (varint, unsigned)
- `value` (len bytes)

Controller TLV types:

- `0x01` pubkey (33 bytes compressed)
- `0x02` script-hash (32 bytes)

##### profile_hint_tlv (when present)

TLV type:

- `0x10` UTF-8 text hint: e.g. `"rxd.game/game_item_v1"`

---

#### Style A: Commit scriptPubKey (OP_RETURN)

```
scriptPubKey = OP_RETURN <PUSHDATA(MAGIC||commit_payload)>
```

Exact op layout:

- `0x6a` OP_RETURN
- followed by a single push opcode (PUSHDATA) and the bytes `MAGIC||commit_payload`

---

#### Style B: Commit "chunked" script (OP_3)

```
scriptPubKey = OP_3 <PUSHDATA(MAGIC)> <PUSHDATA(commit_payload)>
```

Notes:

- The **first push after OP_3** MUST be `MAGIC`
- The **next push** MUST be `commit_payload`
- Additional pushes MAY follow but MUST be ignored by indexers

This matches existing indexers that scan for `OP_3` then magic then decode the next chunk.

---

### Reveal Envelope

#### Reveal Required Fields

Reveal MUST carry:

- `canonical_metadata_bytes` (CBOR canonical preferred)
- Optional file payload chunks (for `content.mode="inline"`)

#### Style A: Reveal scriptPubKey (OP_RETURN)

```
scriptPubKey = OP_RETURN <PUSHDATA(MAGIC||V2||0x00)> <PUSHDATA(canonical_metadata_bytes)> [<PUSHDATA(file_chunk_i)>...]
```

#### Style B: Reveal "chunked" script (OP_3)

```
scriptPubKey = OP_3 <PUSHDATA(MAGIC)> <PUSHDATA(canonical_metadata_bytes)> [<PUSHDATA(file_chunk_i)>...]
```

Indexers MUST:

1. locate `OP_3`, then confirm the next push equals `MAGIC`
2. interpret the _following push_ as `canonical_metadata_bytes`
3. treat any further pushes as file payload chunks in-order

---

### Update Envelope (Optional)

#### Update Bytes (Normative)

Update bytes are canonical bytes of an update object:

- MUST include `glyph` reference (e.g. reveal outpoint)
- MUST include `prev` reference (previous update outpoint or null)
- MUST include `update` (partial object containing only allowed fields)
- MUST include `auth` proving controller authorization (see §5.3)

#### Update Script Templates

**Style B (recommended):**

```
scriptPubKey = OP_3 <PUSHDATA("gly")> <PUSHDATA(update_bytes)>
```

#### Authorization (`auth`) Structure (Normative)

The `auth` field MUST contain:

```json
{
  "auth": {
    "type": "sig | script",
    "pubkey": "<hex, if type=sig>",
    "sig": "<hex>",
    "sighash": "all | single | none",
    "script_witness": ["<hex>", "..."]
  }
}
```

For `type="sig"`:

- `pubkey` MUST match `mutable.controller`
- `sig` is a signature over the message: `SHA256("glyph-v2-update:" || SHA256(update_canonical_bytes_without_sig))`
- `sighash` specifies the sighash mode (default: `all`)

For `type="script"`:

- `script_witness` provides script satisfaction data
- The script hash MUST match `mutable.controller`

---

### Validation Rules (Indexer-Normative)

Commit ↔ reveal:

- Compute `commit_hash = SHA256(canonical_metadata_bytes)`
- Commit is valid if it matches the commit payload's `commit_hash`
- RECOMMENDED: Reveal metadata includes `commit_outpoint` field referencing the commit transaction

If `has_content_root`:

- indexer computes content root from declared content list (see §7)

Updates:

- MUST be authorized by controller
- MUST only alter whitelisted paths declared in `mutable.fields`

---

### Content Root Algorithm (Normative)

When `flags & 0x01` (has_content_root) is set, the content root provides integrity verification
for all declared content files.

#### Merkle Tree Construction

1. For each file in `content.primary` + `content.files` (in declaration order):
   - Compute leaf: `SHA256(path_utf8 || 0x00 || hash_bytes)`
2. Build a binary Merkle tree:
   - If odd number of leaves, duplicate the last leaf
   - Interior node: `SHA256(left_child || right_child)`
3. The root is `content_root`

#### Verification

Indexers MUST verify that the declared `content_root` matches the computed Merkle root.
Mismatches SHOULD be flagged but MAY still be indexed (implementation choice).

---

## Backwards Compatibility

This REP introduces new envelope formats but maintains compatibility with Glyph v1 by using a version byte discriminator.

## Rationale

Two envelope styles are provided to balance different needs:
- Style A is optimized for minimal overhead
- Style B maintains compatibility with existing Glyph v1 parsers

## Reference Implementation

See REP-3004 for indexer implementation guide and C++ examples.

## Security Considerations

- Reserved flag bits MUST be zero to prevent forward compatibility issues
- Size limits prevent denial-of-service attacks via oversized payloads
- Varint encoding must be validated to prevent integer overflow attacks

## Reserved for Future Extensions

The following areas are explicitly deferred to future REPs:

- Alternative envelope styles beyond A and B
- Batch commit/reveal for multiple glyphs
- Compressed envelope formats

## Copyright

This document is licensed under the MIT License.
