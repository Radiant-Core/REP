```
REP: 3004
Title: Glyph v2 Indexer & C++ Implementation Guide
Author: C. Donnachie
Status: Draft
Type: Informational
Created: 2026-01-24
Requires: REP-3001, REP-3002, REP-3003
License: MIT
Original: RIP-GLYPH-0005
```

## Abstract

This document provides implementation guidance for Glyph v2 indexers, including parsing strategies, data models, validation rules, and C++ code examples.

## Motivation

Consistent indexer implementations are essential for the Glyph ecosystem. This guide ensures that all indexers process Glyph transactions identically, enabling interoperability between wallets and applications.

## Specification

### High-Level Pipeline

For each transaction, an indexer should:

1. Scan outputs for commit envelopes (REP-3002 Style A/B)
2. Scan outputs for reveal envelopes (REP-3002 Style A/B)
3. Scan outputs for update envelopes (optional)
4. Validate linkages and store records in a database

---

### Parsing (Recommended Approach)

#### Script Chunking

Create a helper that parses a script into pushes and opcodes:

- Identify `OP_3` occurrences
- For each `OP_3`, read subsequent pushdatas
- Match the first push to MAGIC `gly`
- The _next push_ is interpreted as:
  - **commit_payload** (commit)
  - **canonical_metadata_bytes** (reveal)
  - **update_bytes** (update)

#### Commit Payload Decode

Decode payload:

- `version` (1 byte) — MUST be `0x02`
- `flags` (1 byte)
- `commit_hash` (32 bytes)
- optional fields based on flags

Validate:

- version == 2
- reserved flag bits are 0

---

### Canonical Encoding & Hashing

#### Canonical CBOR (Preferred)

Canonical CBOR requires:

- shortest integer encoding
- map keys sorted by length then lexicographic UTF-8 bytes
- deterministic output

Recommended: decode → validate types → canonical re-encode → hash.

#### Hashing

Compute:

- `commit_hash = SHA256(canonical_metadata_bytes)`

Reject reveal if the commit hash mismatches its referenced commit.

---

### Linking Commit ↔ Reveal

Policy choices (indexer-defined but MUST be deterministic):

- simplest: "most recent prior commit by same creator pubkey within N blocks"
- stronger: reveal includes an explicit `commit_outpoint` field in metadata (RECOMMENDED)

For this v2 draft, RECOMMENDED:

- Reveal metadata SHOULD include `commit_outpoint` field (see REP-3001 §7.2)
- Indexers SHOULD require `commit_outpoint` when present and reject mismatches
- Fallback heuristic: match by commit_hash within recent blocks (e.g., 100 blocks)

---

### Data Model (DB)

Suggested tables:

### glyphs

- glyph_id (text, primary key; e.g. reveal outpoint)
- commit_outpoint (text)
- commit_hash (blob32)
- type (text)
- name (text)
- created (int)
- creator_pubkey (blob33 nullable)
- metadata_cbor (blob)
- policy_renderable (bool)
- policy_executable (bool)
- indexed_at_height (int)
- status (text): `valid | orphaned | malformed`

### files

- glyph_id (text)
- path (text)
- mime (text)
- size (int)
- hash_hex (text)
- is_primary (bool)
- is_ref (bool)
- uri (text nullable)

### updates

- glyph_id (text)
- update_outpoint (text, primary key)
- prev_outpoint (text nullable)
- update_bytes (blob)
- controller (text)
- applied_at_height (int)
- status (text): `valid | orphaned`

### rels

- glyph_id (text)
- rel (text)
- target (text)

### key_reveals (for REP-3009)

- reveal_id (text, primary key)
- target_glyph_id (text)
- key_hash (text)
- material_bytes (blob)
- revealed_at_height (int)
- status (text): `valid | orphaned`

---

### Validation Rules Checklist

- commit envelope parses + version==2
- reveal metadata decodes and is canonical (or re-serialized canonically for hashing)
- commit_hash matches
- content hashes match declared payloads (if inline)
- mutable updates:
  - controller auth valid
  - update only touches allowed fields

---

### C++ Implementation Notes

#### Script Parsing

- Use Bitcoin-style script parsing (`CScript`, `GetOp`, etc.)
- Extract pushdata safely: bounds checks, reject malformed pushes

#### SHA256

- Use existing `CSHA256` / `Hash` utilities

#### Canonical CBOR

Options:

- (A) Use a CBOR library and add a canonical "re-encode" step
- (B) Implement a minimal canonical encoder for the limited set of types:
  - uint/int, bool, bytes, text, arrays, maps with text keys

Recommended: decode → canonical re-encode → hash.

#### JSON Canonical (Fallback)

If you accept JSON, use RFC 8785 JCS.

---

### Abuse Resistance

- enforce max metadata size (e.g. 256KB)
- enforce max inline bytes per glyph
- surface `executable=true`
- avoid quadratic parsing (stream decode)

---

### Chain Reorganization Handling (Normative)

#### Reorg Detection

Indexers MUST handle chain reorganizations:

- Track `indexed_at_height` for all records
- Monitor for blocks being orphaned

#### Rollback Procedure

When a reorg orphans blocks at height H or above:

1. Mark all glyphs with `indexed_at_height >= H` as `status = orphaned`
2. Mark all updates with `applied_at_height >= H` as `status = orphaned`
3. Re-scan the new chain from height H
4. Re-validate and update status for affected records

#### Conflict Resolution

If the same `commit_hash` appears in both old and new chains:

- Prefer the version in the winning chain
- Update `commit_outpoint` and `glyph_id` as needed

---

### Mempool Considerations

#### Reveal-before-commit

A reveal transaction may enter the mempool before its commit:

- Indexers SHOULD queue unmatched reveals temporarily
- Match when commit arrives or reject after timeout (e.g., 24 hours)

#### Double-reveal Attacks

Multiple reveals may reference the same commit:

- Only the first confirmed reveal is valid
- Subsequent reveals SHOULD be rejected

#### Update Ordering

Updates form a chain via `prev` references:

- Indexers MUST apply updates in chain order
- Out-of-order updates should be queued until predecessors confirm

---

### Performance Recommendations

#### Batch Processing

- Process blocks in batches of 100-1000 transactions
- Use database transactions to ensure atomicity

#### Parallel Parsing

- Parse envelopes in parallel across multiple threads
- Synchronize only for database writes

#### Caching

- Cache recently seen commit_hashes for fast reveal matching
- Cache controller pubkeys for update validation

#### Index Optimization

Create database indexes on:

- `glyphs(commit_hash)`
- `glyphs(type, created)`
- `files(glyph_id)`
- `updates(glyph_id, applied_at_height)`

---

## Reference Implementation

```cpp
bool TryParseGlyphEnvelope(const CScript& spk, GlyphEnvelope& out);

uint256 CommitHashFromMetadata(const std::vector<uint8_t>& canonicalBytes) {
    return SHA256(canonicalBytes);
}

bool ValidateReveal(const GlyphCommit& commit, const std::vector<uint8_t>& metaBytes) {
    return CommitHashFromMetadata(metaBytes) == commit.commitHash;
}

void HandleReorg(int orphanedHeight) {
    db.Execute("UPDATE glyphs SET status='orphaned' WHERE indexed_at_height >= ?", orphanedHeight);
    db.Execute("UPDATE updates SET status='orphaned' WHERE applied_at_height >= ?", orphanedHeight);
    RescanFromHeight(orphanedHeight);
}
```

## Backwards Compatibility

This guide is designed for Glyph v2 indexers. Indexers supporting both v1 and v2 should check the version byte after the magic to determine which parsing path to use.

## Rationale

The design choices in this guide prioritize:
- Determinism across implementations
- Robustness against chain reorganizations
- Performance for high-throughput indexing

## Security Considerations

- Validate all input sizes to prevent memory exhaustion attacks
- Use streaming parsers to avoid quadratic complexity
- Rate-limit API endpoints to prevent denial of service
- Sanitize all user-facing output to prevent injection attacks

## Copyright

This document is licensed under the MIT License.
