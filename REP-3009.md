```
REP: 3009
Title: Timelock / Reveal Mechanisms for Encrypted Glyphs
Author: C. Donnachie
Status: Draft
Type: Standard
Created: 2026-01-24
Requires: REP-3006
License: MIT
Original: RIP-GLYPH-0009
```

## Abstract

This proposal defines interoperable mechanisms to **reveal decryption keys in the future** for encrypted Glyphs.
It supports:

- key publication at or after a specified **block height** or **time**
- optional precommitment to the key (hash-commit)
- key reveal via a dedicated **reveal-key Glyph** or via an **update**

These mechanisms are **application-level conventions**; consensus does not enforce secrecy or timing.

## Motivation

Creators may want "locked until…" behavior:

- scheduled content drops
- auctions where content unlocks later
- puzzles / scavenger hunts
- game items with hidden traits until reveal

---

### Threat Model Notes

- The chain cannot prevent someone from publishing a key early.
- The chain cannot prevent recipients from sharing keys.
- Timing guarantees are best-effort and depend on confirmation time.

---

## Specification

### Mechanism A — Hash-Commit then Reveal (Recommended)

#### Commit to the Key

In the encrypted Glyph metadata, include:

```json
"reveal": {
  "scheme": "hash-commit",
  "key_hash": { "algo": "sha256", "hex": "<sha256(key_material)>" },
  "unlock": {
    "min_height": 1234567,
    "min_time": 1765000000
  }
}
```

`key_material` is one of:

- raw CEK
- passphrase-derived secret
- a JSON object containing CEK + parameters (canonicalized before hashing)

#### Reveal the Key Later

At/after the unlock condition, publish a **Key Reveal** object on-chain (see §6).
Wallets verify:

- `sha256(revealed_key_material) == key_hash`
- chain height/time satisfies constraints

---

### Mechanism B — Key Reveal via Update (When mutable is enabled)

If the encrypted Glyph allows updates (REP-3001 `mutable.allowed=true`),
the controller MAY publish an update whose payload contains the reveal object.

Pros:

- binds the reveal to the glyph's update chain

Cons:

- requires mutable support and controller auth

#### Update-based Reveal Example

```json
{
  "glyph": "abc123...def:0",
  "prev": null,
  "update": {
    "reveal_key": {
      "material": {
        "kind": "cek",
        "bytes": "f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff000102030405060708090a0b0c0d0e0f"
      }
    }
  },
  "auth": {
    "type": "sig",
    "pubkey": "02abc123...",
    "sig": "304402..."
  }
}
```

---

### Key Reveal Object (Normative)

Key reveal data MUST be canonicalized (CBOR canonical preferred) and carried in a v2 envelope
as either:

- a dedicated reveal-key Glyph (`type="other"` with `app.schema="key_reveal_v1"`), OR
- an update payload per REP-3002 update envelope.

#### Schema: `key_reveal_v1`

```json
{
  "v": 1,
  "schema": "key_reveal_v1",
  "target": "<glyphid-or-outpoint>",
  "material": {
    "kind": "cek | passphrase | wrapped_cek_bundle",
    "bytes": "<hex>",
    "note": "optional"
  }
}
```

> **Note:** The `v: 1` in `key_reveal_v1` is the **schema version**, not the Glyph protocol version.
> When published as a dedicated Glyph, the outer envelope uses `v: 2` per REP-3001.

Rules:

- `target` MUST identify the encrypted glyph.
- `material.bytes` MUST be the exact bytes committed to by `key_hash` (Mechanism A), if used.

---

### Unlock Conditions (Normative Interpretation)

If both `min_height` and `min_time` are provided, wallets MUST require both to be satisfied.
If only one is provided, wallets require that one.

- `min_height` refers to the **best chain height** at the time the reveal is processed.
- `min_time` refers to the **median time past (MTP)** of the current best block.

> **Normative:** Implementations MUST use MTP for `min_time` to reduce timestamp manipulation risk.

---

### Recommended Wallet UX

Wallets SHOULD:

- show a countdown / "locked until height/time"
- accept a manual key even before unlock (but warn user it may be invalid)
- verify key hash match before attempting decryption
- track multiple candidate key reveals and choose the earliest valid one

---

### Example

Encrypted Glyph includes:

```json
"reveal": {
  "scheme": "hash-commit",
  "key_hash": { "algo": "sha256", "hex": "..." },
  "unlock": { "min_height": 1500000 }
}
```

Later, a reveal-key Glyph publishes:

```json
{
  "v": 1,
  "schema": "key_reveal_v1",
  "target": "outpoint:abcd...:1",
  "material": { "kind": "cek", "bytes": "<hex>" }
}
```

Wallet validates `sha256(material.bytes)==key_hash`, checks height ≥ 1,500,000, then decrypts.

---

## Security Considerations

- Early key publication cannot be prevented; only detected.
- If the CEK is revealed publicly, the content becomes public forever.
- Timelock provides **coordination**, not enforcement—once the key is known, it cannot be "unrevealed."
- For stronger guarantees, consider threshold schemes or hardware-based timelocks (out of scope for this REP).

---

## Reference Implementation

### Indexer Integration

Indexers SHOULD track key reveals to enable automatic decryption when keys become available.

See REP-3004 §5 for the recommended `key_reveals` table schema:

| Column        | Type | Description                                    |
| ------------- | ---- | ---------------------------------------------- |
| glyph_id      | TEXT | Target glyph outpoint                          |
| reveal_tx     | TEXT | Transaction containing the reveal              |
| material_kind | TEXT | cek, passphrase, or wrapped_cek_bundle         |
| key_hash      | TEXT | SHA256 of revealed material (for verification) |
| revealed_at   | INT  | Block height when reveal was confirmed         |

Indexers SHOULD:

- Verify `sha256(material.bytes) == key_hash` before storing
- Track reveal height for unlock condition verification
- Handle competing reveals by accepting the first valid one

---

### Cancellation Considerations

This specification does **not** define a cancellation mechanism for scheduled reveals.

Rationale:

- Once a hash commitment is published, the commitment cannot be "taken back."
- A controller could publish a new encrypted version with a different key, but the original commitment remains valid.
- Applications requiring cancellation should consider multi-party threshold schemes or not committing the hash until reveal time.

---

## Backwards Compatibility

This REP extends REP-3006 and does not affect existing Glyphs.

## Rationale

Hash-commit-then-reveal provides cryptographic proof that the key was predetermined, preventing manipulation of the reveal timing.

## References

- REP-3001: Core Glyph Protocol
- REP-3002: Envelope Formats
- REP-3004: Indexer Guide
- REP-3006: Encrypted Content Extension
- If the reveal is published in mempool, observers can decrypt before confirmation.
- For "surprise drops", publish the reveal in a transaction with adequate fee and wait for confirmation before announcing.

## Copyright

This document is licensed under the MIT License.
