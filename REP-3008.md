```
REP: 3008
Title: Recipient Key Wrapping (Encrypt CEK to N Recipients)
Author: C. Donnachie
Status: Draft
Type: Standard
Created: 2026-01-24
Requires: REP-3006
License: MIT
Original: RIP-GLYPH-0008
```

## Abstract

This proposal specifies a standard mechanism to distribute access to encrypted Glyph content by
**wrapping the Content Encryption Key (CEK)** to **N recipients**, using an ECIES-like construction.

The encrypted payload remains ciphertext per REP-3006. This REP standardizes:

- how to derive a per-recipient Key Encryption Key (KEK)
- how to wrap (encrypt) the CEK
- how to represent recipients in metadata

## Motivation

Passphrase unlock is simple but weak in practice. Recipient wrapping enables:

- sharing locked content with specific wallet identities
- multi-recipient distribution (e.g., members, buyers)
- no shared password needed

---

## Specification

### Overview

For each recipient `R`:

1. Sender generates an ephemeral keypair `E`
2. Derive shared secret `S = X25519(E_priv, R_pub)`
3. Derive `KEK = HKDF-SHA256(S, salt, info)`
4. Wrap CEK with `AEAD(KEK, nonce, aad, CEK)` to produce `wrapped_cek`
5. Publish `(E_pub, salt, info, nonce, aad, wrapped_cek)` in `crypto.key.wrap.recipients[]`

Recipients use their private key to compute the same `S`, derive `KEK`, and decrypt `wrapped_cek` to recover CEK.

---

### Algorithms (Normative)

Implementations MUST support:

- Key agreement: **X25519**
- KDF: **HKDF-SHA256**
- Wrap AEAD: **AES-256-GCM**

Implementations MAY support:

- Wrap AEAD: ChaCha20-Poly1305 (IETF)
- Alternative key agreement (secp256k1 ECIES) â€” reserved for future REP

---

### Metadata Fields (Normative)

In REP-3006 `crypto.key.wrap`, set:

```json
"wrap": {
  "alg": "x25519-hkdf-aes256gcm",
  "recipients": [
    {
      "kid": "string identifier",
      "pubkey": "recipient_x25519_pubkey_hex",
      "eph_pubkey": "sender_ephemeral_x25519_pubkey_hex",
      "salt": "hex",
      "info": "utf8 string",
      "nonce": "hex",
      "aad": "hex",
      "wrapped_cek": "hex"
    }
  ]
}
```

#### Algorithm Identifiers

| Identifier                     | Key Agreement | KDF         | Wrap AEAD         |
| ------------------------------ | ------------- | ----------- | ----------------- |
| `x25519-hkdf-aes256gcm`        | X25519        | HKDF-SHA256 | AES-256-GCM       |
| `x25519-hkdf-chacha20poly1305` | X25519        | HKDF-SHA256 | ChaCha20-Poly1305 |

#### Field Requirements

- `kid` SHOULD be unique within the recipients array (for UX purposes)
- `pubkey` MUST be X25519 public key (32 bytes)
- `eph_pubkey` MUST be X25519 public key (32 bytes)
- `salt` MUST be 16 bytes (recommended)
- `nonce` MUST be 12 bytes (AES-GCM)
- `aad` MAY be empty but is RECOMMENDED
- `wrapped_cek` is `AESGCM(KEK).encrypt(nonce, CEK, aad)` (ciphertext||tag)

---

### Wallet Behavior (Normative)

Wallets implementing this REP MUST:

- detect a recipient entry matching a local identity
- compute shared secret using local private key and published `eph_pubkey`
- derive `KEK` via HKDF-SHA256 with the published `salt` and `info`
- decrypt `wrapped_cek` to recover CEK
- use CEK to decrypt the encrypted file payload(s) per REP-3006

Wallets MUST NOT publish recovered CEK or plaintext without user consent.

---

## Reference Implementation

### Deterministic Test Vector

This section provides an end-to-end deterministic vector.

#### Inputs

Recipient private key (X25519, 32 bytes hex):

```text
77076d0a7318a57d3c16c17251b26645df4c2f87ebc0992ab177fba51db92c2a
```

Recipient public key (X25519, 32 bytes hex):

```text
8520f0098930a754748b7ddcb43ef75a0dbf3a0d26381af4eba4a98eaa9b4e6a
```

Sender ephemeral private key (X25519, 32 bytes hex):

```text
5dab087e624a8a4b79e17f8b83800ee66f3bb1292618b6fd1c2f8b27ff88e0eb
```

Sender ephemeral public key (X25519, 32 bytes hex):

```text
de9edb7d7b7dc1b4d35b61c2ece435373f8343c85b78674dadfc7e146f882b4f
```

HKDF salt (16 bytes hex):

```text
000102030405060708090a0b0c0d0e0f
```

HKDF info (utf8):

```text
RIP-GLYPH-0008 KEK v1
```

CEK (32 bytes hex):

```text
f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff000102030405060708090a0b0c0d0e0f
```

Wrap nonce (12 bytes hex):

```text
0f0e0d0c0b0a090807060504
```

Wrap AAD (utf8):

```text
glyph-cek-wrap
```

#### Derived Shared Secret S (hex)

```text
4a5d9d5ba4ce2de1728e3bf480350f25e07e21c947d19e3376f09b3c1e161742
```

#### Derived KEK (HKDF output, 32 bytes hex)

```text
8db9199f9f05dbd192fbb48e300dad3ea032dc09fadaca322b7450a350069b32
```

#### wrapped_cek = AES-256-GCM(KEK, nonce, aad, CEK) (ciphertext||tag hex)

```text
ba0a07b089b7f9eede86ecdfe8a96fa20ed1b201b438c42a63a827a7ff5301257c121bc6459bcf7e8fb56e627ace0029
```

#### SHA256(wrapped_cek) (hex)

```text
56a6fe97a016e85d6ad710fe14e1eb5d112857469c35da4077bbeb3bb6c2a3c7
```

---

### Multi-recipient Example

Two recipients, Alice and Bob:

```json
"wrap": {
  "alg": "x25519-hkdf-aes256gcm",
  "recipients": [
    {
      "kid": "alice",
      "pubkey": "8520f0098930a754748b7ddcb43ef75a0dbf3a0d26381af4eba4a98eaa9b4e6a",
      "eph_pubkey": "de9edb7d7b7dc1b4d35b61c2ece435373f8343c85b78674dadfc7e146f882b4f",
      "salt": "000102030405060708090a0b0c0d0e0f",
      "info": "RIP-GLYPH-0008 KEK v1",
      "nonce": "0f0e0d0c0b0a090807060504",
      "aad": "676c7970682d63656b2d77726170",
      "wrapped_cek": "ba0a07b089b7f9eede86ecdfe8a96fa20ed1b201b438c42a63a827a7ff5301257c121bc6459bcf7e8fb56e627ace0029"
    },
    {
      "kid": "bob",
      "pubkey": "a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2",
      "eph_pubkey": "f1e2d3c4b5a6978889a0b1c2d3e4f5061728394a5b6c7d8e9f0a1b2c3d4e5f6a",
      "salt": "101112131415161718191a1b1c1d1e1f",
      "info": "RIP-GLYPH-0008 KEK v1",
      "nonce": "101112131415161718191a1b",
      "aad": "676c7970682d63656b2d77726170",
      "wrapped_cek": "<bob's wrapped CEK>"
    }
  ]
}
```

Note: Each recipient entry uses a **unique ephemeral keypair and nonce**.

---

## Backwards Compatibility

This REP extends REP-3006 and does not affect existing Glyphs without encryption.

## Rationale

X25519 + HKDF + AES-256-GCM is a widely supported, well-audited combination that provides strong security guarantees.

## Security Considerations

- **Ephemeral key reuse is FORBIDDEN**: Each recipient entry MUST use a unique ephemeral keypair.
  Reusing an ephemeral key across recipients allows recipients to compute each other's KEK.
- Each recipient entry SHOULD use a unique nonce.
- Nonce reuse under the same KEK breaks AES-GCM security.
- `kid` is metadata only; do not rely on it for authentication or authorization.
- `kid` SHOULD be unique within a single `recipients[]` array for clarity.
- Wallet UX should clearly show which identity unlocked the content.
- Consider rate-limiting decryption attempts to mitigate timing attacks.

## Copyright

This document is licensed under the MIT License.
