# REP-3014: Glyph Burn Mechanism

| Field | Value |
|-------|-------|
| REP | 3014 |
| Title | Glyph Burn Mechanism |
| Author | Radiant Community |
| Status | Draft |
| Type | Standards Track |
| Category | Token Standard |
| Created | 2026-01-25 |
| Requires | REP-3001, REP-3002 |

---

## Abstract

This REP defines `GLYPH_BURN` (protocol ID 6), a standardized mechanism for permanently destroying Glyph tokens while preserving a verifiable on-chain proof of the burn. The mechanism ensures that photons (satoshis) locked in burned tokens are returned to the user's wallet, destroying only the token reference while recovering the underlying value.

---

## Motivation

Token burns serve several purposes:

1. **Supply reduction**: Deflationary mechanics for fungible tokens
2. **Redemption**: Exchanging tokens for goods/services
3. **Upgrades**: Burning v1 tokens to mint v2 equivalents
4. **Proof of destruction**: Verifiable removal from circulation
5. **Game mechanics**: Consuming items in games

Without a standard burn mechanism:
- Each project invents its own burn format
- Indexers cannot accurately track circulating supply
- Users may lose photons to improperly constructed burns
- Burn verification is inconsistent

`GLYPH_BURN` provides a unified standard ensuring:
- Verifiable on-chain burn proofs
- Photon recovery to user wallets
- Consistent indexer support
- Clear burn semantics for FT and NFT

---

## Specification

### 1. Protocol Identifier

```
GLYPH_BURN = 6
```

Burn transactions include protocol ID 6 in the burn proof payload.

### 2. Core Principle: Photon Recovery

**Critical requirement**: Burning a token MUST return the photon value to the user.

```
Token UTXO (tokenRef, 1000 photons)
       â†“
  Burn Transaction
       â†“
â”œâ”€â”€ Output 0: Burn proof (0 photons)
â””â”€â”€ Output 1: User change (995 photons, minus fees)
```

The token reference is destroyed (not propagated to any output), but the photon value is preserved.

### 3. Burn Transaction Structure

#### 3.1 Inputs

```
Input 0: Token UTXO to burn
         - Contains token reference (normal or singleton)
         - Has photon value V
Input 1+: Fee funding UTXOs (optional, if token value < fees)
```

#### 3.2 Outputs

```
Output 0: Burn proof
          - Value: 0 photons
          - Script: OP_RETURN <burn_payload>

Output 1: User change
          - Value: V - fees (recovered photons)
          - Script: User's P2PKH

Output 2+: Additional change (optional)
```

#### 3.3 Key Validation Rules

1. Token reference MUST exist in an input
2. Token reference MUST NOT exist in any output
3. Burn proof MUST be valid Glyph envelope
4. Photon value MUST be returned to user (minus fees)

### 4. Burn Proof Format

#### 4.1 OP_RETURN Structure

```
OP_RETURN
<PUSHDATA(MAGIC || V2 || BURN_PAYLOAD)>
```

Where:
- `MAGIC` = `676c79` (gly)
- `V2` = `0x02`
- `BURN_PAYLOAD` = CBOR-encoded burn object

#### 4.2 Burn Payload Schema

```json
{
  "v": 2,
  "p": [6],
  "action": "burn",
  "token": {
    "ref": "<token_reference_hex>",
    "type": "nft" | "ft"
  },
  "amount": 500,
  "reason": "optional burn reason",
  "timestamp": "2026-01-25T12:00:00Z"
}
```

#### 4.3 Field Specifications

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `v` | integer | Yes | Version (2) |
| `p` | array | Yes | Protocol IDs, must include 6 |
| `action` | string | Yes | Must be "burn" |
| `token.ref` | string | Yes | Token reference being burned (hex) |
| `token.type` | string | Yes | Token type: "nft" or "ft" |
| `amount` | integer | Conditional | Amount burned (required for FT) |
| `reason` | string | No | Human-readable burn reason |
| `timestamp` | string | No | ISO8601 timestamp |

### 5. Burn Types

#### 5.1 NFT Burn (Full)

Burning an NFT destroys the singleton reference:

```json
{
  "v": 2,
  "p": [6],
  "action": "burn",
  "token": {
    "ref": "abc123...",
    "type": "nft"
  },
  "reason": "Upgraded to v2"
}
```

**Transaction**:
```
Input:  NFT UTXO (singletonRef, 1 photon)
Output 0: OP_RETURN burn proof (0 photons)
Output 1: Change to user (0 photons after fees, or funded)
```

#### 5.2 FT Burn (Full)

Burning all fungible tokens from a UTXO:

```json
{
  "v": 2,
  "p": [6],
  "action": "burn",
  "token": {
    "ref": "def456...",
    "type": "ft"
  },
  "amount": 10000
}
```

**Transaction**:
```
Input:  FT UTXO (tokenRef, 10000 photons = 10000 tokens)
Output 0: OP_RETURN burn proof (0 photons)
Output 1: Change to user (9995 photons after fees)
```

#### 5.3 FT Burn (Partial)

Burning some tokens while keeping others:

```json
{
  "v": 2,
  "p": [6],
  "action": "burn",
  "token": {
    "ref": "def456...",
    "type": "ft"
  },
  "amount": 5000
}
```

**Transaction**:
```
Input:  FT UTXO (tokenRef, 10000 photons = 10000 tokens)
Output 0: OP_RETURN burn proof (0 photons)
Output 1: FT change (5000 tokens remaining, tokenRef)
Output 2: RXD change (fees covered from elsewhere)
```

For partial burns, the token reference IS propagated to the remaining balance output.

### 6. Contract Script Modifications

#### 6.1 Burn-Aware FT Script

The standard FT script already supports burns via value-sum validation:

```
// Existing FT validation
inputs.value >= outputs.value  // True when some value is "missing" (burned)
```

No script modification required for FT burns.

#### 6.2 Burn-Aware NFT Script

NFT singletons naturally support burnsâ€”if the singleton is not pushed to an output, the token is effectively burned. The burn proof is optional metadata.

### 7. Indexer Requirements

#### 7.1 Burn Detection

Indexers MUST detect burns by:

1. Scanning for `GLYPH_BURN` protocol in OP_RETURN outputs
2. Parsing burn payload
3. Verifying token ref existed in inputs
4. Verifying token ref does not exist in outputs (or reduced for partial FT)
5. Recording burn in database

#### 7.2 Burn Validation

Indexers MUST validate:
- `action` field equals "burn"
- `token.ref` is valid 36-byte reference
- `amount` is positive (for FT)
- Burn amount â‰¤ input token balance (for FT)
- Token type matches actual token type

#### 7.3 Database Schema

```sql
CREATE TABLE burns (
  id SERIAL PRIMARY KEY,
  burn_txid BYTEA NOT NULL,
  token_ref BYTEA NOT NULL,
  token_type VARCHAR(3) NOT NULL,  -- 'nft' or 'ft'
  amount BIGINT,                    -- null for NFT
  reason TEXT,
  burned_by TEXT,                   -- address that burned
  block_height INTEGER,
  created_at TIMESTAMP,
  
  CONSTRAINT valid_type CHECK (token_type IN ('nft', 'ft'))
);

CREATE INDEX idx_burns_token ON burns(token_ref);
CREATE INDEX idx_burns_height ON burns(block_height);
```

#### 7.4 API Endpoints

```
GET /burns                          â€” List all burns
GET /burns?token=:ref               â€” Burns for specific token
GET /burns?address=:addr            â€” Burns by address
GET /tokens/:ref/supply             â€” Circulating supply (total - burned)
GET /tokens/:ref/burns              â€” Burn history for token
```

#### 7.5 Supply Calculation

For fungible tokens:
```
circulating_supply = total_minted - total_burned
```

### 8. Wallet Implementation

#### 8.1 Burn Flow

```
1. User selects token(s) to burn
2. Wallet shows confirmation:
   "Burn 500 TOKENS?"
   "This action cannot be undone."
   "You will recover X photons."
3. User confirms
4. Wallet constructs burn transaction:
   - Token UTXO as input
   - Burn proof as OP_RETURN output
   - Change output to user
5. Sign and broadcast
```

#### 8.2 UI Requirements

Wallets MUST:
- Show clear warning before burning
- Display amount being burned
- Show photon recovery amount
- Provide burn reason input (optional)
- Show burn confirmation after broadcast

#### 8.3 Burn Receipt

After successful burn, show:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ”¥ Burn Successful                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Token:    Example Token #42                            â”‚
â”‚  Amount:   500 TOKENS                                   â”‚
â”‚  Reason:   Redemption for merch                         â”‚
â”‚  TXID:     abc123...                                    â”‚
â”‚  Photons:  495 recovered                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 9. Burn Reasons (Recommended)

Standard reason codes for common scenarios:

| Reason | Description |
|--------|-------------|
| `redemption` | Exchanged for goods/services |
| `upgrade` | Burned for token upgrade |
| `deflationary` | Supply reduction |
| `game_mechanic` | In-game item consumption |
| `expired` | Token expired |
| `error` | Burned due to error/duplicate |
| `voluntary` | User's choice |

Example:
```json
{
  "reason": "redemption:merch_order_12345"
}
```

### 10. Examples

#### 10.1 NFT Burn

**Scenario**: User burns an NFT to claim a physical item.

**Burn proof**:
```json
{
  "v": 2,
  "p": [6],
  "action": "burn",
  "token": {
    "ref": "a1b2c3d4...",
    "type": "nft"
  },
  "reason": "redemption:physical_art_claim"
}
```

**Transaction**:
```
Inputs:
  [0] NFT UTXO: 1000 photons, singleton ref a1b2c3d4...
  [1] Fee UTXO: 5000 photons

Outputs:
  [0] OP_RETURN: burn proof, 0 photons
  [1] Change: 5995 photons to user
```

**Result**: NFT destroyed, 5995 photons returned.

#### 10.2 FT Full Burn

**Scenario**: User burns all their tokens for deflation.

**Burn proof**:
```json
{
  "v": 2,
  "p": [6],
  "action": "burn",
  "token": {
    "ref": "e5f6g7h8...",
    "type": "ft"
  },
  "amount": 100000,
  "reason": "deflationary"
}
```

**Transaction**:
```
Inputs:
  [0] FT UTXO: 100000 photons (100000 tokens), ref e5f6g7h8...

Outputs:
  [0] OP_RETURN: burn proof, 0 photons
  [1] Change: 99995 photons to user
```

**Result**: 100000 tokens burned, 99995 photons returned.

#### 10.3 FT Partial Burn

**Scenario**: User burns half their tokens.

**Burn proof**:
```json
{
  "v": 2,
  "p": [6],
  "action": "burn",
  "token": {
    "ref": "e5f6g7h8...",
    "type": "ft"
  },
  "amount": 50000,
  "reason": "deflationary"
}
```

**Transaction**:
```
Inputs:
  [0] FT UTXO: 100000 photons (100000 tokens), ref e5f6g7h8...
  [1] Fee UTXO: 1000 photons

Outputs:
  [0] OP_RETURN: burn proof, 0 photons
  [1] FT output: 50000 tokens remaining, ref e5f6g7h8...
  [2] Change: 50995 photons to user
```

**Result**: 50000 tokens burned, 50000 tokens remain, 50995 photons returned.

### 11. Security Considerations

#### 11.1 Accidental Burns

Risk: User accidentally burns tokens.

Mitigation:
- Wallet confirmation dialogs
- Burn is an explicit action, not default
- Recovery impossibleâ€”clear warnings required

#### 11.2 Burn Proof Forgery

Risk: Fake burn proof without actually burning.

Mitigation:
- Indexers verify token ref exists in inputs
- Indexers verify token ref absent in outputs
- Proof without valid transaction is ignored

#### 11.3 Double Burn Claims

Risk: Same token claimed burned multiple times.

Mitigation:
- Indexers track burn by (txid, token_ref)
- Subsequent claims for same ref are invalid
- UTXO model prevents actual double-spend

#### 11.4 Photon Loss

Risk: User loses photons in poorly constructed burn.

Mitigation:
- Standard specifies photon recovery
- Wallets MUST include change output
- Burn scripts don't consume photons

### 12. Backwards Compatibility

- v1 tokens can be burned using this mechanism
- Burn proof format is v2-specific
- v1 wallets may not recognize burn UI
- Indexers should support both implicit burns (no proof) and explicit burns (with proof)

#### 12.1 Implicit Burns (Legacy)

Before this REP, burns may have occurred by:
- Sending to unspendable address
- Transactions without burn proof

Indexers SHOULD detect these by:
- Token ref in input, not in output
- No matching burn proof

Mark as "legacy burn" in database.

---

## Test Vectors

### Vector 1: NFT Burn Proof

**Metadata (JSON)**:
```json
{
  "v": 2,
  "p": [6],
  "action": "burn",
  "token": {
    "ref": "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567",
    "type": "nft"
  }
}
```

**CBOR (hex)**:
```
a4617602617081066661637469 6f6e646275726e65746f6b656e
a2637265667824303132333435 3637383961626364656630313233
...
```

### Vector 2: FT Partial Burn

**Input state**:
- Token ref: `aabbccdd...`
- Input balance: 1000000

**Burn payload**:
```json
{
  "v": 2,
  "p": [6],
  "action": "burn",
  "token": { "ref": "aabbccdd...", "type": "ft" },
  "amount": 300000
}
```

**Expected output**:
- Burn proof: 0 photons
- Remaining FT: 700000 tokens with ref
- Change: input_photons - 700000 - fees

### Vector 3: Invalid Burn (Rejected)

**Scenario**: Burn amount exceeds balance

**Input balance**: 100 tokens
**Burn amount**: 500 tokens

**Result**: Indexer rejects burn proof, does not record.

---

## Rationale

### Why Explicit Burn Proofs?

- Clear on-chain record of intent
- Reason tracking for analytics
- Distinguishes intentional burns from lost keys
- Enables burn-specific indexer queries

### Why Photon Recovery?

- Users should not lose value unnecessarily
- Burns destroy the token, not the underlying value
- Prevents accidental financial loss
- Encourages healthy token burning behavior

### Why GLYPH_BURN Protocol ID?

- Consistent with other Glyph extensions
- Enables protocol-level filtering
- Clear signal to indexers and wallets
- Future-proofs for burn extensions

---

## References

1. "Glyph Protocol v2 Core," REP-3001
2. "Glyph v2 Envelope Formats," REP-3002
3. EIP-5679: Token Minting and Burning (Ethereum)
4. Bitcoin OP_RETURN specifications

---

## Copyright

This REP is licensed under the MIT License.
